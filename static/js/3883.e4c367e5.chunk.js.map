{"version":3,"file":"static/js/3883.e4c367e5.chunk.js","mappings":"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","sources":["../../node_modules/mdast-util-phrasing/lib/index.js","../../node_modules/hast-util-to-mdast/lib/all.js","../../node_modules/hast-util-to-mdast/lib/util/own.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-text.js","../../node_modules/hast-util-to-mdast/lib/one.js","../../node_modules/hast-util-to-mdast/lib/util/wrap.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-children.js","../../node_modules/hast-util-to-mdast/lib/util/resolve.js","../../node_modules/unist-util-find-after/lib/index.js","../../node_modules/hast-util-to-text/lib/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/code.js","../../node_modules/trim-trailing-lines/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/del.js","../../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js","../../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../../node_modules/hast-util-to-mdast/lib/handlers/em.js","../../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../../node_modules/hast-util-to-mdast/lib/handlers/img.js","../../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../../node_modules/hast-util-to-mdast/lib/handlers/input.js","../../node_modules/hast-util-to-mdast/lib/handlers/li.js","../../node_modules/hast-util-to-mdast/lib/handlers/list.js","../../node_modules/hast-util-to-mdast/lib/handlers/media.js","../../node_modules/hast-util-to-mdast/lib/handlers/p.js","../../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../../node_modules/hast-util-to-mdast/lib/handlers/table.js","../../node_modules/hast-util-to-mdast/lib/handlers/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/root.js","../../node_modules/hast-util-to-mdast/lib/handlers/text.js","../../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../../node_modules/hast-util-to-mdast/lib/handlers/a.js","../../node_modules/hast-util-to-mdast/lib/handlers/base.js","../../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../../node_modules/hast-util-to-mdast/lib/handlers/br.js","../../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../../node_modules/hast-util-to-mdast/lib/handlers/q.js","../../node_modules/hast-util-to-mdast/lib/handlers/select.js","../../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../../node_modules/hast-util-to-mdast/lib/index.js","../../node_modules/rehype-remark/lib/index.js","../../node_modules/mdast-util-to-markdown/lib/configure.js","../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../node_modules/mdast-util-to-markdown/lib/handle/index.js","../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../node_modules/longest-streak/index.js","../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../node_modules/mdast-util-to-markdown/lib/join.js","../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../node_modules/mdast-util-to-markdown/lib/index.js","../../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {one} from './one.js'\n\n/**\n * @param {H} h\n * @param {Node} parent\n * @returns {Array<MdastNode>}\n */\nexport function all(h, parent) {\n  /** @type {Array<Node>} */\n  // @ts-expect-error Assume `parent` is a parent.\n  const nodes = parent.children || []\n  /** @type {Array<MdastNode>} */\n  const values = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    // @ts-expect-error assume `parent` is a parent.\n    const result = one(h, nodes[index], parent)\n\n    if (Array.isArray(result)) {\n      values.push(...result)\n    } else if (result) {\n      values.push(result)\n    }\n  }\n\n  let start = 0\n  let end = values.length\n\n  while (start < end && values[start].type === 'break') {\n    start++\n  }\n\n  while (end > start && values[end - 1].type === 'break') {\n    end--\n  }\n\n  return start === 0 && end === values.length\n    ? values\n    : values.slice(start, end)\n}\n","export const own = {}.hasOwnProperty\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string} value\n * @returns {string}\n */\nexport function wrapText(h, value) {\n  return h.wrapText ? value : value.replace(/\\r?\\n|\\r/g, ' ')\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {all} from './all.js'\nimport {own} from './util/own.js'\nimport {wrapText} from './util/wrap-text.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @param {Parent|undefined} parent\n * @returns {MdastNode|Array<MdastNode>|void}\n */\nexport function one(h, node, parent) {\n  /** @type {Handle|undefined} */\n  let fn\n\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(h.handlers, node.tagName)) {\n      fn = h.handlers[node.tagName]\n    }\n  } else if (own.call(h.handlers, node.type)) {\n    fn = h.handlers[node.type]\n  }\n\n  if (typeof fn === 'function') {\n    return fn(h, node, parent)\n  }\n\n  return unknown(h, node)\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(h, node) {\n  // @ts-expect-error: Looks like a literal.\n  if (typeof node.value === 'string') {\n    // @ts-expect-error: Looks like a literal.\n    return h(node, 'text', wrapText(h, node.value))\n  }\n\n  return all(h, node)\n}\n","/**\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n */\n\nimport extend from 'extend'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Array<MdastNode>} nodes\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing)\n\n  /**\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode|Array<MdastNode>}\n   */\n  function onphrasing(nodes) {\n    const head = nodes[0]\n\n    if (\n      nodes.length === 1 &&\n      head.type === 'text' &&\n      (head.value === ' ' || head.value === '\\n')\n    ) {\n      return []\n    }\n\n    return {type: 'paragraph', children: nodes}\n  }\n}\n\n/**\n * Check if there are non-phrasing mdast nodes returned.\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesnâ€™t need a wrapper paragraph.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @param {(nodes: Array<MdastPhrasingContent>) => MdastNode|Array<MdastNode>} onphrasing\n * @param {(node: MdastNode) => MdastNode} [onnonphrasing]\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const nonphrasing = onnonphrasing || identity\n  /** @type {Array<MdastNode>} */\n  const flattened = flatten(nodes)\n  /** @type {Array<MdastNode>} */\n  let result = []\n  let index = -1\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < flattened.length) {\n    node = flattened[index]\n\n    if (phrasing(node)) {\n      if (!queue) queue = []\n      queue.push(node)\n    } else {\n      if (queue) {\n        result = result.concat(onphrasing(queue))\n        queue = undefined\n      }\n\n      result = result.concat(nonphrasing(node))\n    }\n  }\n\n  if (queue) {\n    result = result.concat(onphrasing(queue))\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {Array<MdastNode>}\n */\nfunction flatten(nodes) {\n  /** @type {Array<MdastNode>} */\n  let flattened = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we donâ€™t need to worry about that.\n    // `map` maps to its content, so we donâ€™t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What weâ€™ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened = flattened.concat(split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * @param {MdastNode} node\n * @returns {Array<MdastNode>}\n */\nfunction split(node) {\n  // @ts-expect-error Assume parent.\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {MdastNode} child\n   * @returns {MdastNode}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const {children, ...rest} = node\n      return {\n        ...child,\n        // @ts-expect-error: assume matching parent & child.\n        children: [{...extend(true, {}, rest), children: child.children}]\n      }\n    }\n\n    return {...child}\n  }\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode}\n   */\n  function onphrasing(nodes) {\n    // @ts-expect-error: assume parent.\n    const {children, ...rest} = node\n    // @ts-expect-error: assume matching parent & child.\n    return {...extend(true, {}, rest), children: nodes}\n  }\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {MdastNode} node\n * @returns {node is MdastPhrasingContent}\n */\nfunction phrasing(node) {\n  return node.data && node.data.hName\n    ? hastPhrasing({\n        type: 'element',\n        tagName: node.data.hName,\n        properties: {},\n        children: []\n      })\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {unknown} T\n * @param {T} n\n * @returns {T}\n */\nfunction identity(n) {\n  return n\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\nimport {wrap} from './wrap.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @returns {Array<MdastNode>}\n */\nexport function wrapChildren(h, node) {\n  return wrap(all(h, node))\n}\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string|null|undefined} url\n * @returns {string}\n */\nexport function resolve(h, url) {\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (h.frozenBaseUrl) {\n    return String(new URL(url, h.frozenBaseUrl))\n  }\n\n  return url\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n\n * @param parent\n *   Parent node.\n * @param index\n *   Child of `parent` or itâ€™s index.\n * @param test\n *   `unist-util-is`-compatible test.\n * @returns\n *   Child of `parent` or `null`.\n */\nexport const findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &\n   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent\n     * @param {Node | number} index\n     * @param {Test} [test]\n     * @returns {Node | null}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n","/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any node.\n * @typedef {Extract<Node, import('unist').Parent>} Parent\n *   Any parent.\n * @typedef {'normal' | 'pre' | 'nowrap' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` â€” space\n *   *   `1` â€” line ending\n *   *   `2` â€” blank line\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n * @typedef {BreakValue | BreakNumber | undefined} BreakBefore\n *   Any value for a break before.\n * @typedef {BreakValue | BreakNumber | BreakForce | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we donâ€™t need to include void elements here as they donâ€™t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > ðŸ‘‰ **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > weâ€™re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), weâ€™ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Node} tree\n *   Tree to turn into text.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options = {}) {\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<string | BreakNumber>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the nodeâ€™s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: weâ€™re not supporting stylesheets so weâ€™re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: weâ€™ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      // @ts-expect-error Looks like a parent.\n      ...innerTextCollection(children[index], tree, {\n        whitespace,\n        breakBefore: index ? undefined : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {Node} node\n * @param {Parent} parent\n * @param {CollectionInfo} info\n * @returns {Array<string | BreakNumber>}\n */\nfunction innerTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parent} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<string | BreakNumber>} */\n  let items = []\n\n  // Weâ€™re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakNumber | BreakForce | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If nodeâ€™s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If nodeâ€™s computed value of `display` is `table-row`, and nodeâ€™s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If nodeâ€™s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If nodeâ€™s computed value of `display` is `table-cell`, and nodeâ€™s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we donâ€™t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Text | Comment} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<string | BreakNumber>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [â€¦] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and itâ€™s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // donâ€™t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as â€œpreâ€ whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     spaceâ€”even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     contextâ€”is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If weâ€™re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and thereâ€™s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We donâ€™t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Node} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return props.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return props.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst prefix = 'language-'\n\nconst pre = convertElement('pre')\nconst isCode = convertElement('code')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function code(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<string|number>|undefined} */\n  let classList\n  /** @type {string|undefined} */\n  let lang\n\n  if (pre(node)) {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        isCode(child) &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  return h(\n    node,\n    'code',\n    {lang: lang || null, meta: null},\n    trimTrailingLines(wrapText(h, toText(node)))\n  )\n}\n","/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function del(h, node) {\n  return h(node, 'delete', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\n/**\n * @param {Array<MdastListContent>} children\n * @returns {boolean}\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\nimport {all} from '../all.js'\n\n/**\n * @param {H} h\n * @param {Child} node\n * @returns {Array<MdastListContent>}\n */\nexport function wrapListItems(h, node) {\n  const children = all(h, node)\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (child.type !== 'listItem') {\n      children[index] = {\n        type: 'listItem',\n        spread: false,\n        checked: null,\n        // @ts-expect-error Assume `children[index]` is block content.\n        children: [child]\n      }\n    }\n  }\n\n  // @ts-expect-error Assume all `listItem`s\n  return children\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n * @typedef {import('../types.js').MdastBlockContent} MdastBlockContent\n * @typedef {import('../types.js').MdastDefinitionContent} MdastDefinitionContent\n *\n * @typedef Group\n * @property {Array<Element>} titles\n * @property {Array<ElementChild>} definitions\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst div = convertElement('div')\nconst dt = convertElement('dt')\nconst dd = convertElement('dd')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function dl(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<ElementChild>} */\n  let clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  /** @type {Group} */\n  let group = {titles: [], definitions: []}\n  /** @type {ElementChild} */\n  let child\n  /** @type {Array<MdastBlockContent|MdastDefinitionContent>} */\n  let result\n\n  // Unwrap `<div>`s\n  while (++index < children.length) {\n    child = children[index]\n    clean = clean.concat(div(child) ? child.children : child)\n  }\n\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    child = clean[index]\n\n    if (dt(child)) {\n      if (dd(clean[index - 1])) {\n        groups.push(group)\n        group = {titles: [], definitions: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<MdastListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    result = [\n      ...handle(h, groups[index].titles),\n      ...handle(h, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    return h(\n      node,\n      'list',\n      {ordered: false, start: null, spread: listItemsSpread(content)},\n      content\n    )\n  }\n}\n\n/**\n * @param {H} h\n * @param {Array<ElementChild>} children\n * @returns {Array<MdastBlockContent|MdastDefinitionContent>}\n */\nfunction handle(h, children) {\n  const nodes = wrapListItems(h, {type: 'element', tagName: 'x', children})\n\n  if (nodes.length === 0) {\n    return []\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(nodes),\n      children: nodes\n    }\n  ]\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function em(h, node) {\n  return h(node, 'emphasis', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function heading(h, node) {\n  // `else` shouldnâ€™t happen, of courseâ€¦\n  /* c8 ignore next */\n  const depth = Number(node.tagName.charAt(1)) || 1\n  const wrap = h.wrapText\n\n  h.wrapText = false\n  const result = h(node, 'heading', {depth}, all(h, node))\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function img(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(node, 'image', {\n    url: resolve(h, String(props.src || '') || null),\n    title: props.title || null,\n    alt: props.alt || ''\n  })\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function inlineCode(h, node) {\n  return h(node, 'inlineCode', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {hasProperty} from 'hast-util-has-property'\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from './wrap-text.js'\n\nconst option = convertElement('option')\n\n/**\n * @param {H} h\n * @param {Element} node\n * @param {Properties} [properties]\n * @returns {Array<[string, string|null]>}\n */\nexport function findSelectedOptions(h, node, properties) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` exist.\n  const props = properties || node.properties\n  let options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(props.size), 10), 0) ||\n    (props.multiple ? 4 : 1)\n  let index = -1\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Array<[string, string|null]>} */\n  const values = []\n\n  while (++index < options.length) {\n    if (hasProperty(options[index], 'selected')) {\n      selectedOptions.push(options[index])\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  options = list.slice(0, size)\n  index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n    const content = wrapText(h, toText(option))\n    /** @type {Properties} */\n    // @ts-expect-error: `props` exist.\n    const props = option.properties\n    const label = content || String(props.label || '')\n    const value = String(props.value || '') || content\n    values.push([value, label === value ? null : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Parent} node\n */\nfunction findOptions(node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<Element>} */\n  let results = []\n  /** @type {Child} */\n  let child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    // @ts-expect-error Looks like a parent.\n    if (Array.isArray(child.children)) {\n      // @ts-expect-error Looks like a parent.\n      results = results.concat(findOptions(child))\n    }\n\n    if (option(child) && !hasProperty(child, 'disabled')) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {own} from '../util/own.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst datalist = convertElement('datalist')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\n// eslint-disable-next-line complexity\nexport function input(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  let value = String(props.value || props.placeholder || '')\n  /** @type {Array<MdastNode>} */\n  const results = []\n  /** @type {Array<string>} */\n  const texts = []\n  /** @type {Array<[string, string|null]>} */\n  let values = []\n  let index = -1\n  /** @type {string} */\n  let list\n\n  if (props.disabled || props.type === 'hidden' || props.type === 'file') {\n    return\n  }\n\n  if (props.type === 'checkbox' || props.type === 'radio') {\n    return h(\n      node,\n      'text',\n      wrapText(h, h[props.checked ? 'checked' : 'unchecked'])\n    )\n  }\n\n  if (props.type === 'image') {\n    return props.alt || value\n      ? h(node, 'image', {\n          url: resolve(h, String(props.src || '') || null),\n          title: wrapText(h, String(props.title || '')) || null,\n          alt: wrapText(h, String(props.alt || value))\n        })\n      : []\n  }\n\n  if (value) {\n    values = [[value, null]]\n  } else if (\n    // `list` is not supported on these types:\n    props.type !== 'password' &&\n    props.type !== 'file' &&\n    props.type !== 'submit' &&\n    props.type !== 'reset' &&\n    props.type !== 'button' &&\n    props.list\n  ) {\n    list = String(props.list).toUpperCase()\n\n    if (own.call(h.nodeById, list) && datalist(h.nodeById[list])) {\n      values = findSelectedOptions(h, h.nodeById[list], props)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (props.type === 'password') {\n    // Passwords donâ€™t support `list`.\n    values[0] = ['â€¢'.repeat(values[0][0].length), null]\n  }\n\n  if (props.type === 'url' || props.type === 'email') {\n    while (++index < values.length) {\n      value = resolve(h, values[index][0])\n\n      results.push(\n        h(\n          node,\n          'link',\n          {\n            title: null,\n            url: wrapText(h, props.type === 'email' ? 'mailto:' + value : value)\n          },\n          [{type: 'text', value: wrapText(h, values[index][1] || value)}]\n        )\n      )\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  return h(node, 'text', wrapText(h, texts.join(', ')))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {wrapChildren} from '../util/wrap-children.js'\n\nconst p = convertElement('p')\nconst input = convertElement('input')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function li(h, node) {\n  const head = node.children[0]\n  /** @type {boolean|null} */\n  let checked = null\n  /** @type {ElementChild} */\n  let checkbox\n  /** @type {Element|undefined} */\n  let clone\n\n  // Check if this node starts with a checkbox.\n  if (p(head)) {\n    checkbox = head.children[0]\n\n    if (\n      input(checkbox) &&\n      checkbox.properties &&\n      (checkbox.properties.type === 'checkbox' ||\n        checkbox.properties.type === 'radio')\n    ) {\n      checked = Boolean(checkbox.properties.checked)\n      clone = {\n        ...node,\n        children: [\n          {...head, children: head.children.slice(1)},\n          ...node.children.slice(1)\n        ]\n      }\n    }\n  }\n\n  const content = wrapChildren(h, clone || node)\n\n  return h(node, 'listItem', {spread: content.length > 1, checked}, content)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst ol = convertElement('ol')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function list(h, node) {\n  const ordered = ol(node)\n  const children = wrapListItems(h, node)\n  /** @type {number|null} */\n  let start = null\n\n  if (ordered) {\n    start = hasProperty(node, 'start')\n      ? // @ts-expect-error: `props` exist.\n        Number.parseInt(String(node.properties.start), 10)\n      : 1\n  }\n\n  return h(\n    node,\n    'list',\n    {ordered, start, spread: listItemsSpread(children)},\n    children\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toString} from 'mdast-util-to-string'\nimport {visit, EXIT} from 'unist-util-visit'\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapNeeded} from '../util/wrap.js'\n\nconst source = convertElement('source')\nconst video = convertElement('video')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function media(h, node) {\n  let nodes = all(h, node)\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const properties = node.properties\n  const poster = video(node) && String(properties.poster || '')\n  let src = String(properties.src || '')\n  let index = -1\n  /** @type {boolean} */\n  let linkInFallbackContent = false\n  /** @type {ElementChild} */\n  let child\n\n  visit({type: 'root', children: nodes}, 'link', findLink)\n\n  // If the content links to something, or if itâ€™s not phrasingâ€¦\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!src && ++index < node.children.length) {\n    child = node.children[index]\n    if (source(child)) {\n      // @ts-expect-error: `props` are defined.\n      src = String(child.properties.src || '')\n    }\n  }\n\n  // If thereâ€™s a poster defined on the video, create an image.\n  if (poster) {\n    nodes = [\n      {\n        type: 'image',\n        title: null,\n        url: resolve(h, poster),\n        alt: toString({children: nodes})\n      }\n    ]\n  }\n\n  // Link to the media resource.\n  return {\n    type: 'link',\n    // @ts-expect-error Types are broken.\n    title: node.properties.title || null,\n    url: resolve(h, src),\n    // @ts-expect-error Assume phrasing content.\n    children: nodes\n  }\n\n  function findLink() {\n    linkInFallbackContent = true\n    return EXIT\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function p(h, node) {\n  const nodes = all(h, node)\n\n  if (nodes.length > 0) {\n    return h(node, 'paragraph', nodes)\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function strong(h, node) {\n  return h(node, 'strong', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableCell(h, node) {\n  const wrap = h.wrapText\n\n  h.wrapText = false\n\n  const result = h(node, 'tableCell', all(h, node))\n\n  if (node.properties && (node.properties.rowSpan || node.properties.colSpan)) {\n    const data = result.data || (result.data = {})\n    if (node.properties.rowSpan) data.rowSpan = node.properties.rowSpan\n    if (node.properties.colSpan) data.colSpan = node.properties.colSpan\n  }\n\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastTableContent} MdastTableContent\n * @typedef {import('../types.js').MdastRowContent} MdastRowContent\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n *\n * @typedef Info\n * @property {Array<string|null>} align\n * @property {boolean} headless\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {visit, SKIP} from 'unist-util-visit'\nimport {wrapText} from '../util/wrap-text.js'\nimport {all} from '../all.js'\n\nconst thead = convertElement('thead')\nconst tr = convertElement('tr')\nconst cell = convertElement(['th', 'td'])\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function table(h, node) {\n  if (h.inTable) {\n    return h(node, 'text', wrapText(h, toText(node)))\n  }\n\n  h.inTable = true\n\n  const {headless, align} = inspect(node)\n  const rows = toRows(all(h, node), headless)\n  let columns = 1\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const colSpan = Number.parseInt(String(cell.data.colSpan), 10) || 1\n        const rowSpan = Number.parseInt(String(cell.data.rowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Donâ€™t add rows that donâ€™t exist.\n                // Browsers donâ€™t render them either.\n                break\n              }\n\n              /** @type {Array<MdastRowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('colSpan' in cell.data) delete cell.data.colSpan\n        if ('rowSpan' in cell.data) delete cell.data.rowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  h.inTable = false\n\n  return h(node, 'table', {align}, rows)\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Element} node\n * @returns {Info}\n */\nfunction inspect(node) {\n  let headless = true\n  let rowIndex = 0\n  let cellIndex = 0\n  /** @type {Array<string|null>} */\n  const align = [null]\n\n  visit(node, 'element', (child) => {\n    if (child.tagName === 'table' && node !== child) {\n      return SKIP\n    }\n\n    // If there is a `thead`, assume there is a header row.\n    if (cell(child) && child.properties) {\n      if (!align[cellIndex]) {\n        align[cellIndex] = String(child.properties.align || '') || null\n      }\n\n      // If there is a th in the first row, assume there is a header row.\n      if (headless && rowIndex < 2 && child.tagName === 'th') {\n        headless = false\n      }\n\n      cellIndex++\n    } else if (thead(child)) {\n      headless = false\n    } else if (tr(child)) {\n      rowIndex++\n      cellIndex = 0\n    }\n  })\n\n  return {align, headless}\n}\n\n/**\n * Ensure the rows are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @param {boolean} headless\n * @returns {Array<MdastTableContent>}\n */\nfunction toRows(children, headless) {\n  let index = -1\n  /** @type {Array<MdastTableContent>} */\n  const nodes = []\n  /** @type {Array<MdastRowContent>|undefined} */\n  let queue\n\n  // Add an empty header row.\n  if (headless) {\n    nodes.push({type: 'tableRow', children: []})\n  }\n\n  while (++index < children.length) {\n    const node = children[index]\n\n    if (node.type === 'tableRow') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume row content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    nodes[nodes.length - 1].children.push(...queue)\n  }\n\n  index = -1\n\n  while (++index < nodes.length) {\n    nodes[index].children = toCells(nodes[index].children)\n  }\n\n  return nodes\n}\n\n/**\n * Ensure the cells in a row are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @returns {Array<MdastRowContent>}\n */\nfunction toCells(children) {\n  /** @type {Array<MdastRowContent>} */\n  const nodes = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n\n  while (++index < children.length) {\n    node = children[index]\n\n    if (node.type === 'tableCell') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume phrasing content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    node = nodes[nodes.length - 1]\n\n    if (!node) {\n      node = {type: 'tableCell', children: []}\n      nodes.push(node)\n    }\n\n    node.children.push(...queue)\n  }\n\n  return nodes\n}\n","import {all} from '../all.js'\nimport {wrapChildren} from '../util/wrap-children.js'\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\nexport const handlers = {\n  root,\n  text,\n  comment,\n  doctype: ignore,\n\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  address: wrapChildren,\n  article: wrapChildren,\n  aside: wrapChildren,\n  body: wrapChildren,\n  center: wrapChildren,\n  div: wrapChildren,\n  fieldset: wrapChildren,\n  figcaption: wrapChildren,\n  figure: wrapChildren,\n  form: wrapChildren,\n  footer: wrapChildren,\n  header: wrapChildren,\n  hgroup: wrapChildren,\n  html: wrapChildren,\n  legend: wrapChildren,\n  main: wrapChildren,\n  multicol: wrapChildren,\n  nav: wrapChildren,\n  picture: wrapChildren,\n  section: wrapChildren,\n\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\nfunction ignore() {}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Root} Root\n */\n\nimport {all} from '../all.js'\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(h, node) {\n  let children = all(h, node)\n\n  if (h.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  return h(node, 'root', children)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Text} Text\n */\n\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(h, node) {\n  return h(node, 'text', wrapText(h, node.value))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Comment} Comment\n */\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Comment} node\n */\nexport function comment(h, node) {\n  return h(node, 'html', '<!--' + wrapText(h, node.value) + '-->')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function a(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(\n    node,\n    'link',\n    {\n      title: props.title || null,\n      url: resolve(h, String(props.href || '') || null)\n    },\n    all(h, node)\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function base(h, node) {\n  if (!h.baseFound) {\n    h.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || null\n    h.baseFound = true\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {wrapChildren} from '../util/wrap-children.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function blockquote(h, node) {\n  return h(node, 'blockquote', wrapChildren(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function br(h, node) {\n  return h.wrapText ? h(node, 'break') : h(node, 'text', ' ')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function hr(h, node) {\n  return h(node, 'thematicBreak')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function iframe(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  const src = String(props.src || '')\n  const title = String(props.title || '')\n\n  // Only create a link if there is a title.\n  // We canâ€™t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (src && title) {\n    return {\n      type: 'link',\n      title: null,\n      url: resolve(h, src),\n      children: [{type: 'text', value: wrapText(h, title)}]\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function q(h, node) {\n  const expected = h.quotes[h.qNesting % h.quotes.length]\n\n  h.qNesting++\n  const contents = all(h, node)\n  h.qNesting--\n\n  contents.unshift({type: 'text', value: expected.charAt(0)})\n\n  contents.push({\n    type: 'text',\n    value: expected.length > 1 ? expected.charAt(1) : expected\n  })\n\n  return contents\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function select(h, node) {\n  const values = findSelectedOptions(h, node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n  /** @type {[string, string|null]} */\n  let value\n\n  while (++index < values.length) {\n    value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    return h(node, 'text', wrapText(h, results.join(', ')))\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function textarea(h, node) {\n  return h(node, 'text', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableRow(h, node) {\n  return h(node, 'tableRow', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function wbr(h, node) {\n  return h(node, 'text', '\\u200B')\n}\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Properties} Properties\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').HWithoutProps} HWithoutProps\n * @typedef {import('./types.js').HWithProps} HWithProps\n * @typedef {import('./types.js').MdastNode} MdastNode\n * @typedef {import('./types.js').MdastRoot} MdastRoot\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {convert} from 'unist-util-is'\nimport {visit} from 'unist-util-visit'\nimport {one} from './one.js'\nimport {handlers} from './handlers/index.js'\nimport {own} from './util/own.js'\n\nexport {one} from './one.js'\nexport {all} from './all.js'\n\nconst block = convert(['heading', 'paragraph', 'root'])\n\n/**\n * Transform hast to mdast.\n *\n * @param {Node} tree\n *   Tree (hast).\n * @param {Options} [options]\n *   Configuration (optional).\n */\nexport function toMdast(tree, options = {}) {\n  /** @type {Record<string, Element>} */\n  const byId = {}\n  /** @type {MdastNode|MdastRoot} */\n  let mdast\n\n  /**\n   * @type {H}\n   */\n  const h = Object.assign(\n    /**\n     * @type {HWithProps & HWithoutProps}\n     */\n    (\n      /**\n       * @param {Node} node\n       * @param {string} type\n       * @param {Properties|string|Array<Node>} [props]\n       * @param {string|Array<Node>} [children]\n       */\n      (node, type, props, children) => {\n        /** @type {Properties|undefined} */\n        let properties\n\n        if (typeof props === 'string' || Array.isArray(props)) {\n          children = props\n          properties = {}\n        } else {\n          properties = props\n        }\n\n        /** @type {Node} */\n        // @ts-expect-error Assume valid `type` and `children`/`value`.\n        const result = {type, ...properties}\n\n        if (typeof children === 'string') {\n          // @ts-expect-error: Looks like a literal.\n          result.value = children\n        } else if (children) {\n          // @ts-expect-error: Looks like a parent.\n          result.children = children\n        }\n\n        if (node.position) {\n          result.position = node.position\n        }\n\n        return result\n      }\n    ),\n    {\n      nodeById: byId,\n      baseFound: false,\n      inTable: false,\n      wrapText: true,\n      /** @type {string|null} */\n      frozenBaseUrl: null,\n      qNesting: 0,\n      handlers: options.handlers\n        ? {...handlers, ...options.handlers}\n        : handlers,\n      document: options.document,\n      checked: options.checked || '[x]',\n      unchecked: options.unchecked || '[ ]',\n      quotes: options.quotes || ['\"']\n    }\n  )\n\n  visit(tree, 'element', (node) => {\n    const id =\n      node.properties &&\n      'id' in node.properties &&\n      String(node.properties.id).toUpperCase()\n\n    if (id && !own.call(byId, id)) {\n      byId[id] = node\n    }\n  })\n\n  // @ts-expect-error: does return a transformer, that does accept any node.\n  rehypeMinifyWhitespace({newlines: options.newlines === true})(tree)\n\n  const result = one(h, tree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    mdast = {type: 'root', children: result}\n  } else {\n    mdast = result\n  }\n\n  visit(mdast, 'text', ontext)\n\n  return mdast\n\n  /**\n   * Collapse text nodes, and fix whitespace.\n   * Most of this is taken care of by `rehype-minify-whitespace`, but\n   * weâ€™re generating some whitespace too, and some nodes are in the end\n   * ignored.\n   * So clean up.\n   *\n   * @type {import('unist-util-visit/complex-types').BuildVisitor<MdastRoot, 'text'>}\n   */\n  function ontext(node, index, parent) {\n    /* c8 ignore next 3 */\n    if (index === null || !parent) {\n      return\n    }\n\n    const previous = parent.children[index - 1]\n\n    if (previous && previous.type === node.type) {\n      previous.value += node.value\n      parent.children.splice(index, 1)\n\n      if (previous.position && node.position) {\n        previous.position.end = node.position.end\n      }\n\n      // Iterate over the previous node again, to handle its total value.\n      return index - 1\n    }\n\n    node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n    // We donâ€™t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n    // as there the whitespace matters.\n    if (parent && block(parent)) {\n      if (!index) {\n        node.value = node.value.replace(/^[\\t ]+/, '')\n      }\n\n      if (index === parent.children.length - 1) {\n        node.value = node.value.replace(/[\\t ]+$/, '')\n      }\n    }\n\n    if (!node.value) {\n      parent.children.splice(index, 1)\n      return index\n    }\n  }\n}\n\nexport {handlers as defaultHandlers} from './handlers/index.js'\n","/**\n * @typedef {import('hast-util-to-mdast').Options} Options\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new mdast\n * tree (bridge-mode).\n * Without destination, returns the mdast tree: further plugins run on that\n * tree (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `hast-util-to-mdast`.\n */\nconst rehypeRemark =\n  /**\n   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}\n   */\n  (\n    /**\n     * @param {Processor|Options} [destination]\n     * @param {Options} [options]\n     */\n    function (destination, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {Processor|undefined} */\n      let processor\n\n      if (typeof destination === 'function') {\n        processor = destination\n        settings = options || {}\n      } else {\n        settings = destination || {}\n      }\n\n      if (settings.document === undefined || settings.document === null) {\n        settings = Object.assign({}, settings, {document: true})\n      }\n\n      return processor ? bridge(processor, settings) : mutate(settings)\n    }\n  )\n\nexport default rehypeRemark\n\n/**\n * Bridge-mode.\n * Runs the destination with the new mdast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], HastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toMdast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further transformers run on the mdast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>}\n */\nfunction mutate(options = {}) {\n  return (node) => {\n    const result = /** @type {MdastRoot} */ (toMdast(node, options))\n    return result\n  }\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we canâ€™t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If thereâ€™s no infoâ€¦\n      !node.lang &&\n      // And thereâ€™s a non-whitespace characterâ€¦\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnâ€™t start or end in a blankâ€¦\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot â€œformâ€ depending on the\n// previous or next character of sequences.\n// Thereâ€™s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If thereâ€™s no url but there is a titleâ€¦\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that weâ€™re in phrasing, because escapes donâ€™t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnâ€™t matter that\n  // weâ€™ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If thereâ€™s a urlâ€¦\n      node.url &&\n      // And thereâ€™s a no titleâ€¦\n      !node.title &&\n      // And the content of `node` is a single text nodeâ€¦\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the contentâ€¦\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocolâ€¦\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnâ€™t contain ASCII control codes (character escapes and\n      // references donâ€™t work), space, or angle bracketsâ€¦\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that weâ€™re in phrasing, because escapes donâ€™t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If thereâ€™s no url but there is a titleâ€¦\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that weâ€™re in phrasing, because escapes donâ€™t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnâ€™t matter that\n  // weâ€™ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot â€œformâ€ depending on the\n// previous or next character of sequences.\n// Thereâ€™s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If thereâ€™s no url, orâ€¦\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole sizeâ€¦\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)â€¦\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnâ€™t matter that\n  // weâ€™ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If thereâ€™s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // â€¦because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If thereâ€™s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // â€¦because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: weâ€™ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: weâ€™ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What â€œconstructsâ€ we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\n */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],"names":["phrasing","convert","all","h","parent","nodes","children","values","index","length","result","one","Array","isArray","push","start","end","type","slice","own","hasOwnProperty","wrapText","value","replace","node","fn","properties","dataMdast","call","handlers","tagName","unknown","wrap","runs","head","wrapNeeded","onphrasing","onnonphrasing","nonphrasing","identity","flattened","concat","split","flatten","queue","undefined","rest","extend","child","data","hName","hastPhrasing","mdastPhrasing","n","wrapChildren","resolve","url","frozenBaseUrl","String","URL","findAfter","test","is","Error","Number","POSITIVE_INFINITY","indexOf","searchLineFeeds","searchTabOrSpaces","br","convertElement","p","cell","row","notRendered","Boolean","hidden","open","blockOrCaption","toText","tree","options","arguments","block","whitespace","inferWhitespace","breakBefore","breakAfter","results","collectText","innerTextCollection","count","repeat","join","info","prefix","suffix","items","unshift","collectElement","collectPreText","lines","lastIndex","match","exec","trimAndCollapseSpacesAndTabs","charCodeAt","props","noWrap","pre","isCode","code","classList","lang","className","meta","input","codePointAt","trimTrailingLines","del","listItemsSpread","spread","wrapListItems","checked","div","dt","dd","handle","ordered","em","heading","depth","charAt","img","src","title","alt","inlineCode","option","findSelectedOptions","findOptions","size","Math","min","parseInt","multiple","selectedOptions","hasProperty","content","label","datalist","li","checkbox","clone","ol","list","source","video","media","poster","linkInFallbackContent","visit","EXIT","toString","strong","tableCell","rowSpan","colSpan","thead","tr","toCells","root","document","text","comment","doctype","ignore","applet","area","basefont","bgsound","caption","col","colgroup","command","dialog","element","embed","frame","frameset","isindex","keygen","link","math","menu","menuitem","nextid","noembed","noframes","optgroup","param","script","shadow","spacer","style","svg","template","track","abbr","acronym","bdi","bdo","big","blink","button","canvas","cite","details","dfn","font","ins","map","marquee","meter","nobr","noscript","object","output","progress","rb","rbc","rp","rt","rtc","ruby","slot","small","span","sup","sub","tbody","tfoot","time","address","article","aside","body","center","fieldset","figcaption","figure","form","footer","header","hgroup","html","legend","main","multicol","nav","picture","section","a","href","audio","b","base","baseFound","blockquote","dir","dl","clean","groups","group","titles","definitions","h1","h2","h3","h4","h5","h6","hr","i","iframe","image","placeholder","texts","disabled","toUpperCase","nodeById","kbd","listing","mark","plaintext","q","expected","quotes","qNesting","contents","s","samp","select","strike","summary","table","inTable","headless","align","rowIndex","cellIndex","SKIP","inspect","rows","toRows","columns","cells","otherRowIndex","colIndex","newCells","splice","Object","keys","alignIndex","td","textarea","th","tt","u","ul","var","wbr","xmp","toMdast","byId","mdast","assign","position","unchecked","id","rehypeMinifyWhitespace","newlines","previous","destination","settings","processor","file","next","run","error","bridge","mutate","configure","extension","key","extensions","line","_","blank","hardBreak","_1","state","unsafe","character","patternInScope","stack","before","formatCodeAsIndented","fences","checkQuote","marker","quote","emphasis","checkEmphasis","exit","enter","tracker","createTracker","move","containerPhrasing","after","current","peek","formatHeadingAsSetext","literalWithBreak","setext","subexit","safe","imageReference","referenceType","reference","associationId","formatLinkAsAutolink","raw","resourceLink","linkReference","checkBulletOrdered","bulletOrdered","checkRule","rule","checkStrong","shift","indentLines","containerFlow","break","fence","checkFence","sequence","max","substring","TypeError","longestStreak","encode","definition","rank","lastIndexOf","closeAtx","bulletCurrent","bullet","checkBullet","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","bulletLastUsed","useDifferentMarker","firstListItem","indexStack","item","listItem","paragraph","some","d","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","left","right","fullPhrasingSpans","inConstruct","notInConstruct","atBreak","invalid","joinDefinition","containerPhrasingBound","this","containerFlowBound","safeBound","config","remarkStringify","Compiler","name","pop","association","tightDefinitions","zwitch","now","column","lineShift","toMarkdown"],"sourceRoot":""}