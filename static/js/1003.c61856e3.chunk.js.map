{"version":3,"file":"static/js/1003.c61856e3.chunk.js","mappings":"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","sources":["../../node_modules/@lezer/markdown/dist/index.js","../../node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// For reused nodes on gaps, we can't directly put the original\n        /// node into the tree, since that may be bitter than its parent.\n        /// When this happens, we create a dummy tree that is replaced by\n        /// the proper node in `injectGaps` @internal\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0) | (canClose ? 2 /* Mark.Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0) | (close ? 2 /* Mark.Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]+@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.\\w+(\\.\\w+)?)(\\/[^\\s<]*)?/gy;\nconst emailRE = /[\\w.+-]+@[\\w-]+\\.[\\w.-]+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/// Extension that implements autolinking for\n/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\n/// addresses.\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n/// [`Autolink`](#Autolink).\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]{1,4}\\[[ xX]\\])?([ \\t]+)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++) {\n                    insert += context[i].blank(i < e ? context[i + 1].from - insert.length : null, i < e);\n                }\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? context[i + 1].from - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = state.lineBreak + insert;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank(inner.to - inner.from) } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["Type","CompositeBlock","type","value","from","hash","end","children","positions","_classCallCheck","this","hashProp","NodeProp","contextHash","_createClass","key","child","pos","prop","Tree","length","push","nodeSet","_this","arguments","undefined","last","Math","max","types","balance","makeTree","NodeType","none","parentHash","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forwardInner","newPos","skipSpace","countIndent","charCodeAt","pop","to","findColumn","elt","i","goal","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","_DefaultSkipMarkup","_defineProperty","Blockquote","QuoteMark","lineStart","moveBase","space","ListItem","_cx","moveBaseColumn","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","IndentedCode","base","pendingMarks","nextLine","_step","_iterator","_createForOfIteratorHelper","s","n","done","m","err","f","_step2","_iterator2","_step3","_iterator3","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","_step4","_iterator4","_step5","_iterator5","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","_step6","_iterator6","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","scrub","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","_toConsumableArray","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","reusePlaceholders","Map","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","get","finishContext","_step7","_iterator7","mark","reuseFragment","_step8","_iterator8","blockParsers","forward","_step9","_iterator9","leafBlockParsers","parse","lines","_step10","_iterator10","endLeafBlock","stop","_step11","_iterator11","_step12","_iterator12","finishLeaf","RangeError","moveTo","matches","taken","takeNodes","toRelative","moveRangeI","r","lineChunkAt","textOffset","nextFrom","_this$scanLine","scanLine","reset","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","getNodeType","addChild","toTree","injectMarks","top","addGaps","tree","injectGaps","topNode","_step13","_iterator13","inline","Paragraph","TreeElement","Buffer","offset","dummies","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","reuse","propValues","MarkdownParser","_Parser","_inherits","_super","_createSuper","blockNames","inlineParsers","inlineNames","wrappers","_this2","call","nodeTypes","Object","_step14","_iterator14","t","name","id","_step15","_iterator15","w","spec","_nodeSet","config","resolveConfig","nonEmpty","defineNodes","assign","styles","_step16","_iterator16","_loop","_ref","composite","style","some","group","define","props","Array","isArray","Tag","NodeSet","extend","styleTags","apply","remove","_step17","_iterator17","rm","parseBlock","_step18","_iterator18","found","before","findName","splice","endLeaf","_step19","_iterator19","wrap","InlineContext","outer","_step20","char","_iterator20","token","resolveMarkers","Parser","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","_step21","_iterator21","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","open","close","emp","closeSize","k","element","startIndex","elements","_step22","eI","_iterator22","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","dummy","set","is","abs","gapFrom","gapTo","markdownHighlighting","tags","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","leftOverSpace","nextPos","StrikethroughDelim","Strikethrough","strikethrough","addDelimiter","parseRow","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","heading","TaskParser","TaskList","atom","parentType","autolinkRE","urlRE","emailRE","xmppResourceRE","autolinkEmailEnd","lastIndex","GFM","absPos","index","autolinkURLEnd","addElement","parseSubSuper","Superscript","special","Subscript","Emoji","match","data","defineLanguageFacet","commentTokens","headingProp","commonmark","configure","foldNodeProp","add","isHeading","state","doc","lineAt","indentNodeProp","languageDataProp","findSectionEnd","headerNode","level","headerIndent","foldService","of","syntaxTree","resolveInner","mkLang","Language","commonmarkLanguage","markdownLanguage","Context","spaceBefore","spaceAfter","item","maxWidth","number","String","itemNumber","getContext","context","replace","sliceString","renumberList","changes","prev","insert","insertNewlineContinueMarkup","dispatch","dont","changeByRange","range","empty","isActiveAt","emptyLine","delTo","marker","EditorSelection","blank","lineBreak","prevLine","quoted","continued","charAt","update","scrollIntoView","userEvent","isMark","deleteMarkupBackward","_ref2","scan","childBefore","lastChild","contextNodeForDelete","spaceEnd","markdownKeymap","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","_config$addKeymap","addKeymap","_config$base","_config$completeHTMLT","completeHTMLTags","defaultCode","extensions","support","LanguageSupport","language","languages","defaultLanguage","codeParser","info","LanguageDescription","matchLanguageName","ParseContext","getSkippingParser","load","htmlParser","parseMixed","overlay","infoNode","getChild","parseCode","Prec","high","keymap","lang","autocomplete","htmlTagCompletion","sliceDoc","isTop","options","htmlTagCompletions","validFor","_tagCompletions","htmlCompletionSource","CompletionContext","EditorState"],"sourceRoot":""}