{"version":3,"file":"static/js/399.e858957c.chunk.js","mappings":"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","sources":["../../node_modules/hast-util-is-body-ok-link/index.js","../../node_modules/hast-util-is-body-ok-link/node_modules/hast-util-has-property/index.js","../../node_modules/hast-util-is-body-ok-link/node_modules/hast-util-is-element/convert.js","../../node_modules/hast-util-is-body-ok-link/node_modules/hast-util-is-element/index.js","../../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js","../../node_modules/@lezer/markdown/dist/index.js","../../node_modules/@codemirror/lang-markdown/dist/index.js","../../node_modules/hast-util-embedded/index.js","../../node_modules/hast-util-phrasing/index.js","../../node_modules/html-whitespace-sensitive-tag-names/index.js","../../node_modules/rehype-format/index.js","../../node_modules/rehype-ignore/src/index.ts","../../node_modules/rehype-minify-whitespace/block.js","../../node_modules/rehype-minify-whitespace/content.js","../../node_modules/rehype-minify-whitespace/skippable.js","../../node_modules/rehype-minify-whitespace/index.js","../../node_modules/rehype-video/src/index.ts","../../node_modules/rehype-video/src/detailsNode.ts"],"sourcesContent":["/**\n * @fileoverview\n *   Check if a `link` element is Body OK.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   var h = require('hastscript')\n *   var ok = require('hast-util-is-body-ok-link')\n *\n *   ok(h('link', {itemProp: 'foo'})) //=> true\n *   ok(h('link', {rel: ['stylesheet'], href: 'index.css'})) //=> true\n *   ok(h('link', {rel: ['author'], href: 'index.css'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isBodyOkLink(node)`\n *\n *   * Return `true` for `link` elements with an `itemProp`\n *   * Return `true` for `link` elements with a `rel` list where one or more\n *     entries are `pingback`, `prefetch`, or `stylesheet`.\n */\n\n'use strict'\n\nvar is = require('hast-util-is-element')\nvar has = require('hast-util-has-property')\n\nmodule.exports = ok\n\nvar list = ['pingback', 'prefetch', 'stylesheet']\n\nfunction ok(node) {\n  var length\n  var index\n  var rel\n\n  if (!is(node, 'link')) {\n    return false\n  }\n\n  if (has(node, 'itemProp')) {\n    return true\n  }\n\n  rel = (node.properties || {}).rel || []\n  length = rel.length\n  index = -1\n\n  if (rel.length === 0) {\n    return false\n  }\n\n  while (++index < length) {\n    if (list.indexOf(rel[index]) === -1) {\n      return false\n    }\n  }\n\n  return true\n}\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = hasProperty\n\n// Check if `node` has a set `name` property.\nfunction hasProperty(node, name) {\n  var props\n  var value\n\n  if (!node || !name || typeof node !== 'object' || node.type !== 'element') {\n    return false\n  }\n\n  props = node.properties\n  value = props && own.call(props, name) && props[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n","'use strict'\n\nmodule.exports = convert\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return tagNameFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return element\n  }\n\n  if (typeof test === 'object') {\n    return any(test)\n  }\n\n  if (typeof test === 'function') {\n    return callFactory(test)\n  }\n\n  throw new Error('Expected function, string, or array as test')\n}\n\nfunction convertAll(tests) {\n  var length = tests.length\n  var index = -1\n  var results = []\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\nfunction any(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n// Utility to convert a string a tag name check.\nfunction tagNameFactory(test) {\n  return tagName\n\n  function tagName(node) {\n    return element(node) && node.tagName === test\n  }\n}\n\n// Utility to convert a function check.\nfunction callFactory(test) {\n  return call\n\n  function call(node) {\n    return element(node) && Boolean(test.apply(this, arguments))\n  }\n}\n\n// Utility to return true if this is an element.\nfunction element(node) {\n  return (\n    node &&\n    typeof node === 'object' &&\n    node.type === 'element' &&\n    typeof node.tagName === 'string'\n  )\n}\n","'use strict'\n\nvar convert = require('./convert')\n\nmodule.exports = isElement\n\nisElement.convert = convert\n\n// Check if if `node` is an `element` and whether it passes the given test.\nfunction isElement(node, test, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined\n  var hasIndex = index !== null && index !== undefined\n  var check = convert(test)\n\n  if (\n    hasIndex &&\n    (typeof index !== 'number' || index < 0 || index === Infinity)\n  ) {\n    throw new Error('Expected positive finite index for child node')\n  }\n\n  if (hasParent && (!parent.type || !parent.children)) {\n    throw new Error('Expected parent node')\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index')\n  }\n\n  return check.call(context, node, index, parent)\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}","import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)\n            this.rangeI++;\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(r.end);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser);\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nfunction nodeStart(node, doc) {\n    return doc.sliceString(node.from, node.from + 50);\n}\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(trailing = true) {\n        let result = this.spaceBefore;\n        if (this.node.name == \"Blockquote\")\n            result += \">\";\n        else\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, line, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    let context = [], pos = 0;\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match, start = pos;\n        if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.slice(pos)))) {\n            pos += match[0].length;\n            context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]{1,4}\\[[ xX]\\])?([ \\t]+)/.exec(nodeStart(node, doc)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++)\n                    insert += context[i].blank(i < e);\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let insert = state.lineBreak;\n        let continued = inner.item && inner.item.from < line.from;\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++)\n                insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n","/**\n * @typedef {import('hast').Element & {tagName: 'audio'|'canvas'|'embed'|'iframe'|'img'|'math'|'object'|'picture'|'svg'|'video'}} Embedded\n * @typedef {import('hast-util-is-element').AssertPredicate<Embedded>} AssertEmbedded\n */\n\nimport {convertElement} from 'hast-util-is-element'\n\n/**\n * Check if a node is an embedded element.\n * @type {AssertEmbedded}\n */\n// @ts-ignore Sure, the assertion matches.\nexport const embedded = convertElement([\n  'audio',\n  'canvas',\n  'embed',\n  'iframe',\n  'img',\n  'math',\n  'object',\n  'picture',\n  'svg',\n  'video'\n])\n","import {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {embedded} from 'hast-util-embedded'\nimport bodyOkLink from 'hast-util-is-body-ok-link'\n\nvar basic = convertElement([\n  'a',\n  'abbr',\n  // `area` is in fact only phrasing if it is inside a `map` element.\n  // However, since `area`s are required to be inside a `map` element, and its\n  // a rather involved check, its ignored here for now.\n  'area',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'i',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'output',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'wbr'\n])\n\nvar meta = convertElement('meta')\n\n/**\n * @param {unknown} node\n * @returns {boolean}\n */\nexport function phrasing(node) {\n  return (\n    // @ts-ignore Looks like a text.\n    (node && node.type === 'text') ||\n    basic(node) ||\n    embedded(node) ||\n    bodyOkLink(node) ||\n    (meta(node) && hasProperty(node, 'itemProp'))\n  )\n}\n","/**\n * @fileoverview\n *   List of whitespace sensitive HTML tag names\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\n *\n *   whitespaceSensitiveTagNames\n *   //=> ['pre', 'script', 'style', 'textarea']\n *   ```\n *\n *   ## API\n *\n *   ### `whitespaceSensitiveTagNames`\n *\n *   List of whitespace sensitive HTML tag names (`string[]`).\n */\n\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root['children'][number]} Child\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Child} Node\n *\n * @typedef Options\n *   Configuration.\n * @property {number|string} [indent=2]\n *   Indentation per level (`number`, `string`, default: `2`).\n *   When number, uses that amount of spaces.\n *   When `string`, uses that per indentation level.\n * @property {boolean} [indentInitial=true]\n *   Whether to indent the first level (`boolean`, default: `true`).\n *   This is usually the `<html>`, thus not indenting `head` and `body`.\n * @property {Array<string>} [blanks=[]]\n *   List of tag names to join with a blank line (`Array<string>`, default:\n *   `[]`).\n *   These tags, when next to each other, are joined by a blank line (`\\n\\n`).\n *   For example, when `['head', 'body']` is given, a blank line is added\n *   between these two.\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visitParents, SKIP} from 'unist-util-visit-parents'\nimport {embedded} from 'hast-util-embedded'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\n\nconst minify = rehypeMinifyWhitespace({newlines: true})\n\n/**\n * Format whitespace in HTML.\n *\n * @type {import('unified').Plugin<[Options?] | Array<void>, Root>}\n */\nexport default function rehypeFormat(options = {}) {\n  let indent = options.indent || 2\n  let indentInitial = options.indentInitial\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent)\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true\n  }\n\n  return (tree) => {\n    /** @type {boolean|undefined} */\n    let head\n\n    // @ts-expect-error: fine, its a sync transformer.\n    minify(tree)\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, (node, parents) => {\n      let index = -1\n\n      if (!('children' in node)) {\n        return\n      }\n\n      if (isElement(node, 'head')) {\n        head = true\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP\n      }\n\n      const children = node.children\n      let level = parents.length\n\n      // Dont indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return\n      }\n\n      if (!indentInitial) {\n        level--\n      }\n\n      /** @type {boolean|undefined} */\n      let eol\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true\n          }\n\n          child.value = child.value.replace(\n            / *\\n/g,\n            '$&' + String(indent).repeat(level)\n          )\n        }\n      }\n\n      /** @type {Array<Child>} */\n      const result = []\n      /** @type {Child|undefined} */\n      let previous\n\n      index = -1\n\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (padding(child, head) || (eol && !index)) {\n          addBreak(result, level, child)\n          eol = true\n        }\n\n        previous = child\n        result.push(child)\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as well add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop()\n          previous = result[result.length - 1]\n        }\n\n        addBreak(result, level - 1)\n      }\n\n      node.children = result\n    })\n  }\n\n  /**\n   * @param {Array<Child>} list\n   * @param {number} level\n   * @param {Child} [next]\n   * @returns {void}\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(previous) && blank(next) ? '\\n\\n' : '\\n') +\n      String(indent).repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n\n  /**\n   * @param {Node|undefined} node\n   * @returns {boolean}\n   */\n  function blank(node) {\n    return Boolean(\n      node &&\n        node.type === 'element' &&\n        options.blanks &&\n        options.blanks.length > 0 &&\n        options.blanks.includes(node.tagName)\n    )\n  }\n}\n\n/**\n * @param {Node} node\n * @param {boolean|undefined} head\n * @returns {boolean}\n */\nfunction padding(node, head) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? head || isElement(node, 'script') || embedded(node) || !phrasing(node)\n      : false)\n  )\n}\n","import { Plugin } from 'unified';\nimport { Root, RootContent } from 'hast';\nimport { visit } from 'unist-util-visit';\n\nexport type RehypeIgnoreOptions = {\n  /**\n   *  Character to use for opening delimiter, by default `rehype:ignore:start`\n   */\n  openDelimiter?: string;\n  /**\n   * Character to use for closing delimiter, by default `rehype:ignore:end`\n   */\n  closeDelimiter?: string;\n}\n\nconst rehypeIgnore: Plugin<[RehypeIgnoreOptions?], Root> = (options = {}) => {\n  const { openDelimiter = 'rehype:ignore:start', closeDelimiter = 'rehype:ignore:end' } = options;\n  return (tree) => {\n    visit(tree, (node: Root | RootContent, index, parent) => {\n      if (node.type === 'element' || node.type === 'root') {\n        // const start = node.children.findIndex((item) => item.type === 'comment' && item.value === openDelimiter);\n        // const end = node.children.findIndex((item) => item.type === 'comment' && item.value === closeDelimiter);\n        // if (start > -1 && end > -1) {\n        //   node.children = node.children.filter((_, idx) => idx < start || idx > end);\n        // }\n        let start = false;\n        node.children = node.children.filter((item) => {\n          if (item.type === 'comment' && item.value.trim() === openDelimiter) {\n            start = true;\n            return false\n          }\n          if (item.type === 'comment' && item.value.trim() === closeDelimiter) {\n            start = false;\n            return false\n          }\n          \n          return !start;\n        })\n      }\n    });\n  }\n}\n\nexport default rehypeIgnore;\n","// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nexport const blocks = [\n  'address', // Flow content.\n  'article', // Sections and headings.\n  'aside', // Sections and headings.\n  'blockquote', // Flow content.\n  'body', // Page.\n  'br', // Contribute whitespace intrinsically.\n  'caption', // Similar to block.\n  'center', // Flow content, legacy.\n  'col', // Similar to block.\n  'colgroup', // Similar to block.\n  'dd', // Lists.\n  'dialog', // Flow content.\n  'dir', // Lists, legacy.\n  'div', // Flow content.\n  'dl', // Lists.\n  'dt', // Lists.\n  'figcaption', // Flow content.\n  'figure', // Flow content.\n  'footer', // Flow content.\n  'form', // Flow content.\n  'h1', // Sections and headings.\n  'h2', // Sections and headings.\n  'h3', // Sections and headings.\n  'h4', // Sections and headings.\n  'h5', // Sections and headings.\n  'h6', // Sections and headings.\n  'head', // Page.\n  'header', // Flow content.\n  'hgroup', // Sections and headings.\n  'hr', // Flow content.\n  'html', // Page.\n  'legend', // Flow content.\n  'li', // Block-like.\n  'li', // Similar to block.\n  'listing', // Flow content, legacy\n  'main', // Flow content.\n  'menu', // Lists.\n  'nav', // Sections and headings.\n  'ol', // Lists.\n  'optgroup', // Similar to block.\n  'option', // Similar to block.\n  'p', // Flow content.\n  'plaintext', // Flow content, legacy\n  'pre', // Flow content.\n  'section', // Sections and headings.\n  'summary', // Similar to block.\n  'table', // Similar to block.\n  'tbody', // Similar to block.\n  'td', // Block-like.\n  'td', // Similar to block.\n  'tfoot', // Similar to block.\n  'th', // Block-like.\n  'th', // Similar to block.\n  'thead', // Similar to block.\n  'tr', // Similar to block.\n  'ul', // Lists.\n  'wbr', // Contribute whitespace intrinsically.\n  'xmp' // Flow content, legacy\n]\n","export const content = [\n  // Form.\n  'button',\n  'input',\n  'select',\n  'textarea'\n]\n","export const skippable = [\n  'area',\n  'base',\n  'basefont',\n  'dialog',\n  'datalist',\n  'head',\n  'link',\n  'meta',\n  'noembed',\n  'noframes',\n  'param',\n  'rp',\n  'script',\n  'source',\n  'style',\n  'template',\n  'track',\n  'title'\n]\n","/**\n * rehype plugin to minify whitespace between elements.\n *\n * ## What is this?\n *\n * This package is a plugin that can minify the whitespace between elements.\n *\n * ## When should I use this?\n *\n * You can use this plugin when you want to improve the size of HTML documents.\n *\n * ## API\n *\n * ### `unified().use(rehypeMinifyWhitespace[, options])`\n *\n * Minify whitespace.\n *\n * ##### `options`\n *\n * Configuration (optional).\n *\n * ##### `options.newlines`\n *\n * Whether to collapse runs of whitespace that include line endings to one\n * line ending (`boolean`, default: `false`).\n * The default is to collapse everything to one space.\n *\n * @example\n *   <h1>Heading</h1>\n *   <p><strong>This</strong> and <em>that</em></p>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Root|Root['children'][number]} Node\n *\n * @typedef Options\n * @property {boolean} [newlines=false]\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n *   The default is to collapse to a single space.\n *\n * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace\n *\n * @typedef Context\n * @property {ReturnType<collapseFactory>} collapse\n * @property {Whitespace} whitespace\n * @property {boolean} [before]\n * @property {boolean} [after]\n *\n * @typedef Result\n * @property {boolean} remove\n * @property {boolean} ignore\n * @property {boolean} stripAtStart\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {embedded} from 'hast-util-embedded'\nimport {convert} from 'unist-util-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Minify whitespace.\n *\n * @type {import('unified').Plugin<[Options?]|Array<void>, Root>}\n */\nexport default function rehypeMinifyWhitespace(options = {}) {\n  const collapse = collapseFactory(\n    options.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  return (tree) => {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minify(node, context) {\n  if ('children' in node) {\n    const settings = Object.assign({}, context)\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, context)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (context.whitespace === 'normal') {\n      return minifyText(node, context)\n    }\n\n    // Nave collapse, but no trimming:\n    if (context.whitespace === 'nowrap') {\n      node.value = context.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {remove: false, ignore: ignorableNode(node), stripAtStart: false}\n}\n\n/**\n * @param {Text} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minifyText(node, context) {\n  const value = context.collapse(node.value)\n  const result = {remove: false, ignore: false, stripAtStart: false}\n  let start = 0\n  let end = value.length\n\n  if (context.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (context.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Root|Element} parent\n * @param {Context} context\n * @returns {Result}\n */\nfunction all(parent, context) {\n  let before = context.before\n  const after = context.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(\n      children[index],\n      Object.assign({}, context, {\n        before,\n        after: collapsableAfter(children, index, after)\n      })\n    )\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {remove: false, ignore: false, stripAtStart: Boolean(before || after)}\n}\n\n/**\n * @param {Array<Node>} nodes\n * @param {number} index\n * @param {boolean|undefined} [after]\n * @returns {boolean|undefined}\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true`  boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false`  boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Node} node\n * @returns {boolean|undefined}\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Element} node\n * @returns {boolean}\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {boolean}\n */\nfunction skippable(node) {\n  return (\n    Boolean(\n      'properties' in node && node.properties && node.properties.hidden\n    ) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n * @returns {boolean}\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @returns {string}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {(value: string) => string} replace\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We dont need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Root|Element} node\n * @param {Context} context\n * @returns {Whitespace}\n */\nfunction inferWhiteSpace(node, context) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we cant touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return node.properties.noWrap ? 'nowrap' : context.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return context.whitespace\n}\n","import { Plugin } from 'unified';\nimport { Root, Element } from 'hast';\nimport { visit } from 'unist-util-visit';\nimport { detailsNode } from './detailsNode';\n\nexport type RehypeVideoOptions = {\n  /**\n   * URL suffix verification.\n   * @default /\\/(.*)(.mp4|.mov)$/\n   */\n  test?: RegExp;\n  /**\n   * Support `<details>` tag to wrap <video>.\n   * @default true\n   */\n  details?: boolean;\n}\n\nconst properties = { muted: 'muted', controls: 'controls', style: 'max-height:640px;' };\nconst queryStringToObject = (url: string) =>\n  [...new URLSearchParams(url.split('?!#')[1])].reduce(\n    (a: Record<string, string>, [k, v]) => ((a[k] = v), a),\n    {}\n  );\n\nfunction reElement(node: Element, details: boolean, href: string) {\n  const filename = href.split('/').pop()?.replace(/(\\?|!|\\#|$).+/, '');\n  node.properties = { ...properties, src: href };\n  node.tagName = 'video';\n  node.children = [];\n  const { title = filename }= queryStringToObject(href);\n  if (details) {\n    const reNode = detailsNode(title);\n    reNode.children.push({ ...node });\n    node.children = reNode.children;\n    node.tagName = reNode.tagName;\n    node.properties = reNode.properties;\n  }\n}\n\nconst RehypeVideo: Plugin<[RehypeVideoOptions?], Root> = (options) => {\n  const { test = /\\/(.*)(.mp4|.mov)$/, details = true } = options || {};\n  return (tree) => {\n    visit(tree, 'element', (node, index, parent) => {\n      const isChecked = (str: string) => test.test(str.replace(/(\\?|!|\\#|$).+/g, '').toLocaleLowerCase())\n      const child = node.children[0];\n      const delimiter = /((?:https?:\\/\\/)(?:(?:[a-z0-9]?(?:[a-z0-9\\-]{1,61}[a-z0-9])?\\.[^\\.|\\s])+[a-z\\.]*[a-z]+|(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3})(?::\\d{1,5})*[a-z0-9.,_\\/~#&=;%+?\\-\\\\(\\\\)]*)/g;\n      // const delimiter = /((?:https?:\\/\\/)?(?:(?:[a-z0-9]?(?:[a-z0-9\\-]{1,61}[a-z0-9])?\\.[^\\.|\\s])+[a-z\\.]*[a-z]+|(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3})(?::\\d{1,5})*[a-z0-9.,_\\/~#&=;%+?\\-\\\\(\\\\)]*)/g;\n\n      if (node.tagName === 'p' && node.children.length === 1) {\n        if (child.type === 'text' && delimiter.test(child.value) && isChecked(child.value)) {\n          reElement(node, details, child.value);\n        }\n        if (child.type === 'element' && child.tagName === 'a' && child.properties && typeof child.properties.href === 'string' && isChecked(child.properties.href)) {\n          reElement(node, details, child.properties.href);\n        }\n      }\n    });\n  }\n}\n\nexport default RehypeVideo;\n","import { Element } from 'hast';\n\nexport function detailsNode(title?: string): Element {\n  return {\n    type: 'element',\n    tagName: 'details',\n    properties: { open: true, className: 'octicon octicon-video' },\n    children: [\n      {\n        type: 'element',\n        tagName: 'summary',\n        children: [\n          {\n            type: 'element',\n            tagName: 'svg',\n            properties: {\n              'aria-hidden': true, height: 16, width: 16, viewBox: '0 0 16 16', version: '1.1', 'data-view-component': true,\n              className: 'octicon octicon-device-camera-video'\n            },\n            children: [\n              {\n                type: 'element',\n                tagName: 'path',\n                properties: {\n                  'fill-rule': 'evenodd',\n                  d: 'M16 3.75a.75.75 0 00-1.136-.643L11 5.425V4.75A1.75 1.75 0 009.25 3h-7.5A1.75 1.75 0 000 4.75v6.5C0 12.216.784 13 1.75 13h7.5A1.75 1.75 0 0011 11.25v-.675l3.864 2.318A.75.75 0 0016 12.25v-8.5zm-5 5.075l3.5 2.1v-5.85l-3.5 2.1v1.65zM9.5 6.75v-2a.25.25 0 00-.25-.25h-7.5a.25.25 0 00-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-4.5z'\n                },\n                children: [],\n              }\n            ]\n          },\n          {\n            type: 'element',\n            tagName: 'span',\n            properties: {\n              'aria-label': `Video description ${title || ''}`\n            },\n            children: [\n              {\n                type: 'text',\n                value: title || ''\n              }\n            ]\n          },\n          {\n            type: 'element',\n            tagName: 'span',\n            properties: {\n              className: 'dropdown-caret'\n            },\n            children: []\n          }\n        ]\n      }\n    ]\n  }\n}"],"names":["is","require","has","module","exports","node","length","index","rel","properties","list","indexOf","own","hasOwnProperty","name","props","value","type","call","undefined","convert","test","tagName","element","tagNameFactory","tests","checks","results","convertAll","matches","apply","this","arguments","any","Boolean","callFactory","Error","isElement","parent","context","hasParent","hasIndex","check","Infinity","children","_objectDestructuringEmpty","obj","TypeError","Type","CompositeBlock","from","hash","end","positions","hashProp","NodeProp","child","pos","prop","Tree","push","nodeSet","last","Math","max","tree","types","balance","makeTree","NodeType","parentHash","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forwardInner","newPos","skipSpace","countIndent","charCodeAt","pop","to","findColumn","elt","i","goal","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","moveBase","space","ListItem","_cx","moveBaseColumn","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","scrub","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","finishContext","mark","reuseFragment","blockParsers","forward","leafBlockParsers","parse","lines","endLeafBlock","stop","finishLeaf","RangeError","moveTo","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","r","lineChunkAt","textOffset","nextFrom","scanLine","reset","handler","skipContextMarkup","chunk","lineChunks","eol","getNodeType","none","addChild","toTree","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","blockNames","inlineParsers","inlineNames","wrappers","nodeTypes","Object","t","id","w","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","Parser","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","open","close","emp","closeSize","k","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","markdownHighlighting","tags","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","overlay","info","infoNode","getChild","StrikethroughDelim","Strikethrough","addDelimiter","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","TaskParser","GFM","parentType","parseSubSuper","addElement","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commonmark","configure","foldNodeProp","state","doc","lineAt","indentNodeProp","languageDataProp","mkLang","Language","commonmarkLanguage","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","support","language","ParseContext","load","nodeStart","sliceString","Context","spaceBefore","spaceAfter","item","number","String","itemNumber","getContext","replace","renumberList","changes","prev","insert","isMark","markdownKeymap","key","run","dispatch","syntaxTree","changeByRange","range","empty","isActiveAt","resolveInner","emptyLine","delTo","marker","EditorSelection","blank","lineBreak","prevLine","quoted","continued","charAt","update","scrollIntoView","userEvent","scan","childBefore","lastChild","contextNodeForDelete","spaceEnd","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","defaultCode","extensions","LanguageSupport","Prec","keymap","embedded","convertElement","basic","meta","whitespaceSensitiveTagNames","minify","rehypeMinifyWhitespace","newlines","rehypeFormat","options","indentInitial","repeat","head","visitParents","parents","SKIP","level","padding","includes","previous","addBreak","whitespace","tail","blanks","bodyOkLink","hasProperty","phrasing","openDelimiter","closeDelimiter","visit","trim","blocks","skippable","ignorableNode","collapse","collapseFactory","replaceNewlines","replaceWhitespace","settings","blocklike","noWrap","inferWhiteSpace","collapsableAfter","ignore","stripAtStart","all","removable","minifyText","inferBoundary","contents","hidden","skippables","character","muted","controls","reElement","details","href","filename","split","src","URLSearchParams","reduce","v","reNode","className","height","width","viewBox","version","d","detailsNode","isChecked","toLocaleLowerCase"],"sourceRoot":""}