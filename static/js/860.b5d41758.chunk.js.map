{"version":3,"file":"static/js/860.b5d41758.chunk.js","mappings":"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","sources":["../../node_modules/@lezer/markdown/dist/index.js","../../node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]{1,4}\\[[ xX]\\])?([ \\t]+)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++) {\n                    insert += context[i].blank(i < e ? context[i + 1].from - insert.length : null, i < e);\n                }\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? context[i + 1].from - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = state.lineBreak + insert;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank(inner.to - inner.from) } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["Type","CompositeBlock","type","value","from","hash","end","children","positions","this","hashProp","NodeProp","child","pos","prop","Tree","length","push","nodeSet","last","Math","max","tree","types","balance","makeTree","NodeType","parentHash","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forwardInner","newPos","skipSpace","countIndent","charCodeAt","pop","to","findColumn","elt","i","goal","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","moveBase","space","ListItem","_cx","moveBaseColumn","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","scrub","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","finishContext","mark","reuseFragment","blockParsers","forward","leafBlockParsers","parse","lines","endLeafBlock","stop","finishLeaf","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","r","lineChunkAt","textOffset","nextFrom","scanLine","reset","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","getNodeType","none","addChild","toTree","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","blockNames","inlineParsers","inlineNames","wrappers","nodeTypes","Object","t","name","id","w","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","props","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","Parser","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","open","close","emp","closeSize","k","element","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","markdownHighlighting","tags","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","overlay","info","infoNode","getChild","StrikethroughDelim","Strikethrough","addDelimiter","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","TaskParser","GFM","parentType","parseSubSuper","addElement","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commonmark","configure","foldNodeProp","state","doc","lineAt","indentNodeProp","languageDataProp","mkLang","Language","commonmarkLanguage","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","support","language","ParseContext","load","Context","spaceBefore","spaceAfter","item","maxWidth","number","String","itemNumber","getContext","context","replace","sliceString","renumberList","changes","prev","insert","insertNewlineContinueMarkup","dispatch","syntaxTree","changeByRange","range","empty","isActiveAt","resolveInner","emptyLine","delTo","marker","EditorSelection","blank","lineBreak","prevLine","quoted","index","continued","charAt","update","scrollIntoView","userEvent","isMark","deleteMarkupBackward","scan","childBefore","lastChild","contextNodeForDelete","spaceEnd","markdownKeymap","key","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","defaultCode","extensions","LanguageSupport","Prec","keymap"],"sourceRoot":""}