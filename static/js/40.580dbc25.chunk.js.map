{"version":3,"file":"static/js/40.580dbc25.chunk.js","mappings":"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","sources":["../../node_modules/@lezer/markdown/dist/index.js","../../node_modules/@codemirror/lang-markdown/dist/index.js","../../node_modules/hast-util-to-mdast/lib/all.js","../../node_modules/hast-util-to-mdast/lib/util/own.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-text.js","../../node_modules/hast-util-to-mdast/lib/one.js","../../node_modules/mdast-util-phrasing/index.js","../../node_modules/hast-util-to-mdast/lib/util/wrap.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-children.js","../../node_modules/hast-util-to-mdast/lib/util/resolve.js","../../node_modules/unist-util-find-after/index.js","../../node_modules/hast-util-to-text/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/code.js","../../node_modules/trim-trailing-lines/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/del.js","../../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js","../../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../../node_modules/hast-util-to-mdast/lib/handlers/em.js","../../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../../node_modules/hast-util-to-mdast/lib/handlers/img.js","../../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../../node_modules/hast-util-to-mdast/lib/handlers/input.js","../../node_modules/hast-util-to-mdast/lib/handlers/li.js","../../node_modules/hast-util-to-mdast/lib/handlers/list.js","../../node_modules/hast-util-to-mdast/lib/handlers/media.js","../../node_modules/hast-util-to-mdast/lib/handlers/p.js","../../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../../node_modules/hast-util-to-mdast/lib/handlers/table.js","../../node_modules/hast-util-to-mdast/lib/handlers/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/root.js","../../node_modules/hast-util-to-mdast/lib/handlers/text.js","../../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../../node_modules/hast-util-to-mdast/lib/handlers/a.js","../../node_modules/hast-util-to-mdast/lib/handlers/base.js","../../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../../node_modules/hast-util-to-mdast/lib/handlers/br.js","../../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../../node_modules/hast-util-to-mdast/lib/handlers/q.js","../../node_modules/hast-util-to-mdast/lib/handlers/select.js","../../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../../node_modules/hast-util-to-mdast/lib/index.js","../../node_modules/rehype-remark/lib/index.js","../../node_modules/mdast-util-to-markdown/lib/configure.js","../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../node_modules/mdast-util-to-markdown/lib/handle/index.js","../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../node_modules/longest-streak/index.js","../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../node_modules/mdast-util-to-markdown/lib/join.js","../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../node_modules/mdast-util-to-markdown/lib/index.js","../../node_modules/remark-stringify/index.js","../../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)\n            this.rangeI++;\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(r.end);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser);\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nfunction nodeStart(node, doc) {\n    return doc.sliceString(node.from, node.from + 50);\n}\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(trailing = true) {\n        let result = this.spaceBefore;\n        if (this.node.name == \"Blockquote\")\n            result += \">\";\n        else\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, line, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    let context = [], pos = 0;\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match, start = pos;\n        if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.slice(pos)))) {\n            pos += match[0].length;\n            context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]{1,4}\\[[ xX]\\])?([ \\t]+)/.exec(nodeStart(node, doc)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++)\n                    insert += context[i].blank(i < e);\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let insert = state.lineBreak;\n        let continued = inner.item && inner.item.from < line.from;\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++)\n                insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {one} from './one.js'\n\n/**\n * @param {H} h\n * @param {Node} parent\n * @returns {Array.<MdastNode>}\n */\nexport function all(h, parent) {\n  /** @type {Array.<Node>} */\n  // @ts-expect-error Assume `parent` is a parent.\n  const nodes = parent.children || []\n  /** @type {Array.<MdastNode>} */\n  const values = []\n  let index = -1\n  let length = nodes.length\n  let child = nodes[index + 1]\n\n  // Trim initial and final `<br>`s.\n  // Theyre not semantic per HTML, and they cant be made in markdown things\n  // like paragraphs or headings.\n  while (child && child.type === 'element' && child.tagName === 'br') {\n    index++\n    child = nodes[index + 1]\n  }\n\n  child = nodes[length - 1]\n\n  while (\n    length - 1 > index &&\n    child &&\n    child.type === 'element' &&\n    child.tagName === 'br'\n  ) {\n    length--\n    child = nodes[length - 1]\n  }\n\n  while (++index < length) {\n    // @ts-expect-error assume `parent` is a parent.\n    const result = one(h, nodes[index], parent)\n\n    if (Array.isArray(result)) {\n      values.push(...result)\n    } else if (result) {\n      values.push(result)\n    }\n  }\n\n  return values\n}\n","export const own = {}.hasOwnProperty\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string} value\n * @returns {string}\n */\nexport function wrapText(h, value) {\n  return h.wrapText ? value : value.replace(/\\r?\\n|\\r/g, ' ')\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {all} from './all.js'\nimport {own} from './util/own.js'\nimport {wrapText} from './util/wrap-text.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @param {Parent|undefined} parent\n * @returns {MdastNode|Array.<MdastNode>|void}\n */\nexport function one(h, node, parent) {\n  /** @type {Handle|undefined} */\n  let fn\n\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(h.handlers, node.tagName)) {\n      fn = h.handlers[node.tagName]\n    }\n  } else if (own.call(h.handlers, node.type)) {\n    fn = h.handlers[node.type]\n  }\n\n  if (typeof fn === 'function') {\n    return fn(h, node, parent)\n  }\n\n  return unknown(h, node)\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(h, node) {\n  // @ts-expect-error: Looks like a literal.\n  if (typeof node.value === 'string') {\n    // @ts-expect-error: Looks like a literal.\n    return h(node, 'text', wrapText(h, node.value))\n  }\n\n  return all(h, node)\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * @type {AssertPredicatePhrasing}\n */\n// @ts-ignore hush, its fine!\nexport const phrasing = convert([\n  'break',\n  'delete',\n  'emphasis',\n  'footnote',\n  'footnoteReference',\n  'image',\n  'imageReference',\n  'inlineCode',\n  'link',\n  'linkReference',\n  'strong',\n  'text'\n])\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n */\n\nimport extend from 'extend'\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Array.<MdastNode>} nodes\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing)\n\n  /**\n   * @param {Array.<MdastPhrasingContent>} nodes\n   * @returns {MdastNode|Array.<MdastNode>}\n   */\n  function onphrasing(nodes) {\n    const head = nodes[0]\n\n    if (\n      nodes.length === 1 &&\n      head.type === 'text' &&\n      (head.value === ' ' || head.value === '\\n')\n    ) {\n      return []\n    }\n\n    return {type: 'paragraph', children: nodes}\n  }\n}\n\n/**\n * Check if there are non-phrasing mdast nodes returned.\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesnt need a wrapper paragraph.\n *\n * @param {Array.<MdastNode>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array.<MdastNode>} nodes\n * @param {(nodes: Array.<MdastPhrasingContent>) => MdastNode|Array.<MdastNode>} onphrasing\n * @param {(node: MdastNode) => MdastNode} [onnonphrasing]\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const nonphrasing = onnonphrasing || identity\n  /** @type {Array.<MdastNode>} */\n  const flattened = flatten(nodes)\n  /** @type {Array.<MdastNode>} */\n  let result = []\n  let index = -1\n  /** @type {Array.<MdastPhrasingContent>|undefined} */\n  let queue\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < flattened.length) {\n    node = flattened[index]\n\n    if (phrasing(node)) {\n      if (!queue) queue = []\n      queue.push(node)\n    } else {\n      if (queue) {\n        result = result.concat(onphrasing(queue))\n        queue = undefined\n      }\n\n      result = result.concat(nonphrasing(node))\n    }\n  }\n\n  if (queue) {\n    result = result.concat(onphrasing(queue))\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array.<MdastNode>} nodes\n * @returns {Array.<MdastNode>}\n */\nfunction flatten(nodes) {\n  /** @type {Array.<MdastNode>} */\n  let flattened = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we dont need to worry about that.\n    // `map` maps to its content, so we dont need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What well do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened = flattened.concat(split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * @param {MdastNode} node\n * @returns {Array.<MdastNode>}\n */\nfunction split(node) {\n  // @ts-expect-error Assume parent.\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {MdastNode} child\n   * @returns {MdastNode}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const {children, ...rest} = node\n      return {\n        ...child,\n        // @ts-expect-error: assume matching parent & child.\n        children: [{...extend(true, {}, rest), children: child.children}]\n      }\n    }\n\n    return {...child}\n  }\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array.<MdastPhrasingContent>} nodes\n   * @returns {MdastNode}\n   */\n  function onphrasing(nodes) {\n    // @ts-expect-error: assume parent.\n    const {children, ...rest} = node\n    // @ts-expect-error: assume matching parent & child.\n    return {...extend(true, {}, rest), children: nodes}\n  }\n}\n\n/**\n * @template {unknown} T\n * @param {T} n\n * @returns {T}\n */\nfunction identity(n) {\n  return n\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\nimport {wrap} from './wrap.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @returns {Array.<MdastNode>}\n */\nexport function wrapChildren(h, node) {\n  return wrap(all(h, node))\n}\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string|null|undefined} url\n * @returns {string}\n */\nexport function resolve(h, url) {\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (h.frozenBaseUrl) {\n    return String(new URL(url, h.frozenBaseUrl))\n  }\n\n  return url\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport {convert} from 'unist-util-is'\n\nexport var findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n   *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent Parent node\n     * @param {Node|number} index Child of `parent`, or its index\n     * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n     * @returns {Node|null}\n     */\n    function (parent, index, test) {\n      var is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n","/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber|undefined} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce|undefined} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we dont need to include void elements here as they dont have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if were a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @param {Options} [options={}]\n * @returns {string}\n */\nexport function toText(node, options = {}) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  const children = node.children || []\n  const block = blockOrCaption(node)\n  const whitespace = inferWhitespace(node, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let results\n  /** @type {string|BreakNumber} */\n  let value\n  /** @type {number|undefined} */\n  let count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the nodes `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {whitespace, breakBefore: true, breakAfter: true})\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: were not supporting stylesheets so were acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: well have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      // @ts-ignore Looks like a parent.\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  /** @type {Array.<string>} */\n  const result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push('\\n'.repeat(count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whitespace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node)\n    ]\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, options)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let items = []\n  /** @type {BreakNumber|undefined} */\n  let prefix\n  /** @type {BreakNumber|BreakForce|undefined} */\n  let suffix\n\n  // Were ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If nodes computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If nodes computed value of `display` is `table-row`, and nodes CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If nodes used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If nodes computed value of `display` is `table-cell`, and nodes CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we dont deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\nfunction collectText(node, options) {\n  const value = String(node.value)\n  /** @type {Array.<string>} */\n  const lines = []\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  let index = -1\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n  /** @type {string|undefined} */\n  let join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     spaceeven one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     contextis collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    // If were not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and theres no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  // @ts-expect-error: `end` is defined.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * We dont support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  let props\n\n  if (node.type === 'element') {\n    props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return options.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst prefix = 'language-'\n\nconst pre = convertElement('pre')\nconst isCode = convertElement('code')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function code(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array.<string|number>|undefined} */\n  let classList\n  /** @type {string|undefined} */\n  let lang\n\n  if (pre(node)) {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        isCode(child) &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  return h(\n    node,\n    'code',\n    {lang: lang || null, meta: null},\n    trimTrailingLines(wrapText(h, toText(node)))\n  )\n}\n","/**\n * Remove final newline characters from `value`.\n *\n * @param {unknown} value Value with trailing line feeds, coerced to string.\n * @return {string} Value without trailing newlines.\n */\nexport function trimTrailingLines(value) {\n  return String(value).replace(/\\n+$/, '')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function del(h, node) {\n  return h(node, 'delete', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\n/**\n * @param {Array.<MdastListContent>} children\n * @returns {boolean}\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\nimport {all} from '../all.js'\n\n/**\n * @param {H} h\n * @param {Child} node\n * @returns {Array.<MdastListContent>}\n */\nexport function wrapListItems(h, node) {\n  const children = all(h, node)\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (child.type !== 'listItem') {\n      children[index] = {\n        type: 'listItem',\n        spread: false,\n        checked: null,\n        // @ts-expect-error Assume `children[index]` is block content.\n        children: [child]\n      }\n    }\n  }\n\n  // @ts-expect-error Assume all `listItem`s\n  return children\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n * @typedef {import('../types.js').MdastBlockContent} MdastBlockContent\n * @typedef {import('../types.js').MdastDefinitionContent} MdastDefinitionContent\n *\n * @typedef Group\n * @property {Array.<Element>} titles\n * @property {Array.<ElementChild>} definitions\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst div = convertElement('div')\nconst dt = convertElement('dt')\nconst dd = convertElement('dd')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function dl(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array.<ElementChild>} */\n  let clean = []\n  /** @type {Array.<Group>} */\n  const groups = []\n  /** @type {Group} */\n  let group = {titles: [], definitions: []}\n  /** @type {ElementChild} */\n  let child\n  /** @type {Array.<MdastBlockContent|MdastDefinitionContent>} */\n  let result\n\n  // Unwrap `<div>`s\n  while (++index < children.length) {\n    child = children[index]\n    clean = clean.concat(div(child) ? child.children : child)\n  }\n\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    child = clean[index]\n\n    if (dt(child)) {\n      if (dd(clean[index - 1])) {\n        groups.push(group)\n        group = {titles: [], definitions: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array.<MdastListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    result = [\n      ...handle(h, groups[index].titles),\n      ...handle(h, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    return h(\n      node,\n      'list',\n      {ordered: false, start: null, spread: listItemsSpread(content)},\n      content\n    )\n  }\n}\n\n/**\n * @param {H} h\n * @param {Array.<ElementChild>} children\n * @returns {Array.<MdastBlockContent|MdastDefinitionContent>}\n */\nfunction handle(h, children) {\n  const nodes = wrapListItems(h, {type: 'element', tagName: 'x', children})\n\n  if (nodes.length === 0) {\n    return []\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(nodes),\n      children: nodes\n    }\n  ]\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function em(h, node) {\n  return h(node, 'emphasis', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function heading(h, node) {\n  // `else` shouldnt happen, of course\n  /* c8 ignore next */\n  const depth = Number(node.tagName.charAt(1)) || 1\n  const wrap = h.wrapText\n\n  h.wrapText = false\n  const result = h(node, 'heading', {depth}, all(h, node))\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function img(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(node, 'image', {\n    url: resolve(h, String(props.src || '') || null),\n    title: props.title || null,\n    alt: props.alt || ''\n  })\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function inlineCode(h, node) {\n  return h(node, 'inlineCode', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {hasProperty} from 'hast-util-has-property'\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from './wrap-text.js'\n\nconst option = convertElement('option')\n\n/**\n * @param {H} h\n * @param {Element} node\n * @param {Properties} [properties]\n * @returns {Array.<[string, string|null]>}\n */\nexport function findSelectedOptions(h, node, properties) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` exist.\n  const props = properties || node.properties\n  let options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(props.size), 10), 0) ||\n    (props.multiple ? 4 : 1)\n  let index = -1\n  /** @type {Array.<Element>} */\n  const selectedOptions = []\n  /** @type {Array.<[string, string|null]>} */\n  const values = []\n\n  while (++index < options.length) {\n    if (hasProperty(options[index], 'selected')) {\n      selectedOptions.push(options[index])\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  options = list.slice(0, size)\n  index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n    const content = wrapText(h, toText(option))\n    /** @type {Properties} */\n    // @ts-expect-error: `props` exist.\n    const props = option.properties\n    const label = content || String(props.label || '')\n    const value = String(props.value || '') || content\n    values.push([value, label === value ? null : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Parent} node\n */\nfunction findOptions(node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array.<Element>} */\n  let results = []\n  /** @type {Child} */\n  let child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    // @ts-expect-error Looks like a parent.\n    if (Array.isArray(child.children)) {\n      // @ts-expect-error Looks like a parent.\n      results = results.concat(findOptions(child))\n    }\n\n    if (option(child) && !hasProperty(child, 'disabled')) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {own} from '../util/own.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst datalist = convertElement('datalist')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\n// eslint-disable-next-line complexity\nexport function input(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  let value = String(props.value || props.placeholder || '')\n  /** @type {Array.<MdastNode>} */\n  const results = []\n  /** @type {Array.<string>} */\n  const texts = []\n  /** @type {Array.<[string, string|null]>} */\n  let values = []\n  let index = -1\n  /** @type {string} */\n  let list\n\n  if (props.disabled || props.type === 'hidden' || props.type === 'file') {\n    return\n  }\n\n  if (props.type === 'checkbox' || props.type === 'radio') {\n    return h(\n      node,\n      'text',\n      wrapText(h, h[props.checked ? 'checked' : 'unchecked'])\n    )\n  }\n\n  if (props.type === 'image') {\n    return props.alt || value\n      ? h(node, 'image', {\n          url: resolve(h, String(props.src || '') || null),\n          title: wrapText(h, String(props.title || '')) || null,\n          alt: wrapText(h, String(props.alt || value))\n        })\n      : []\n  }\n\n  if (value) {\n    values = [[value, null]]\n  } else if (\n    // `list` is not supported on these types:\n    props.type !== 'password' &&\n    props.type !== 'file' &&\n    props.type !== 'submit' &&\n    props.type !== 'reset' &&\n    props.type !== 'button' &&\n    props.list\n  ) {\n    list = String(props.list).toUpperCase()\n\n    if (own.call(h.nodeById, list) && datalist(h.nodeById[list])) {\n      values = findSelectedOptions(h, h.nodeById[list], props)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (props.type === 'password') {\n    // Passwords dont support `list`.\n    values[0] = [''.repeat(values[0][0].length), null]\n  }\n\n  if (props.type === 'url' || props.type === 'email') {\n    while (++index < values.length) {\n      value = resolve(h, values[index][0])\n\n      results.push(\n        h(\n          node,\n          'link',\n          {\n            title: null,\n            url: wrapText(h, props.type === 'email' ? 'mailto:' + value : value)\n          },\n          [{type: 'text', value: wrapText(h, values[index][1] || value)}]\n        )\n      )\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  return h(node, 'text', wrapText(h, texts.join(', ')))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {wrapChildren} from '../util/wrap-children.js'\n\nconst p = convertElement('p')\nconst input = convertElement('input')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function li(h, node) {\n  const head = node.children[0]\n  /** @type {boolean|null} */\n  let checked = null\n  /** @type {ElementChild} */\n  let checkbox\n  /** @type {Element|undefined} */\n  let clone\n\n  // Check if this node starts with a checkbox.\n  if (p(head)) {\n    checkbox = head.children[0]\n\n    if (\n      input(checkbox) &&\n      checkbox.properties &&\n      (checkbox.properties.type === 'checkbox' ||\n        checkbox.properties.type === 'radio')\n    ) {\n      checked = Boolean(checkbox.properties.checked)\n      clone = {\n        ...node,\n        children: [\n          {...head, children: head.children.slice(1)},\n          ...node.children.slice(1)\n        ]\n      }\n    }\n  }\n\n  const content = wrapChildren(h, clone || node)\n\n  return h(node, 'listItem', {spread: content.length > 1, checked}, content)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst ol = convertElement('ol')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function list(h, node) {\n  const ordered = ol(node)\n  const children = wrapListItems(h, node)\n  /** @type {number|null} */\n  let start = null\n\n  if (ordered) {\n    start = hasProperty(node, 'start')\n      ? // @ts-expect-error: `props` exist.\n        Number.parseInt(String(node.properties.start), 10)\n      : 1\n  }\n\n  return h(\n    node,\n    'list',\n    {ordered, start, spread: listItemsSpread(children)},\n    children\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toString} from 'mdast-util-to-string'\nimport {visit, EXIT} from 'unist-util-visit'\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapNeeded} from '../util/wrap.js'\n\nconst source = convertElement('source')\nconst video = convertElement('video')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function media(h, node) {\n  let nodes = all(h, node)\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const properties = node.properties\n  const poster = video(node) && String(properties.poster || '')\n  let src = String(properties.src || '')\n  let index = -1\n  /** @type {boolean} */\n  let linkInFallbackContent = false\n  /** @type {ElementChild} */\n  let child\n\n  visit({type: 'root', children: nodes}, 'link', findLink)\n\n  // If the content links to something, or if its not phrasing\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!src && ++index < node.children.length) {\n    child = node.children[index]\n    if (source(child)) {\n      // @ts-expect-error: `props` are defined.\n      src = String(child.properties.src || '')\n    }\n  }\n\n  // If theres a poster defined on the video, create an image.\n  if (poster) {\n    nodes = [\n      {\n        type: 'image',\n        title: null,\n        url: resolve(h, poster),\n        alt: toString({children: nodes})\n      }\n    ]\n  }\n\n  // Link to the media resource.\n  return {\n    type: 'link',\n    // @ts-expect-error Types are broken.\n    title: node.properties.title || null,\n    url: resolve(h, src),\n    // @ts-expect-error Assume phrasing content.\n    children: nodes\n  }\n\n  function findLink() {\n    linkInFallbackContent = true\n    return EXIT\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function p(h, node) {\n  const nodes = all(h, node)\n\n  if (nodes.length > 0) {\n    return h(node, 'paragraph', nodes)\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function strong(h, node) {\n  return h(node, 'strong', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableCell(h, node) {\n  const wrap = h.wrapText\n\n  h.wrapText = false\n\n  const result = h(node, 'tableCell', all(h, node))\n\n  if (node.properties && (node.properties.rowSpan || node.properties.colSpan)) {\n    const data = result.data || (result.data = {})\n    if (node.properties.rowSpan) data.rowSpan = node.properties.rowSpan\n    if (node.properties.colSpan) data.colSpan = node.properties.colSpan\n  }\n\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastTableContent} MdastTableContent\n * @typedef {import('../types.js').MdastRowContent} MdastRowContent\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n *\n * @typedef Info\n * @property {Array.<string|null>} align\n * @property {boolean} headless\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {visit, SKIP} from 'unist-util-visit'\nimport {wrapText} from '../util/wrap-text.js'\nimport {all} from '../all.js'\n\nconst thead = convertElement('thead')\nconst tr = convertElement('tr')\nconst cell = convertElement(['th', 'td'])\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function table(h, node) {\n  if (h.inTable) {\n    return h(node, 'text', wrapText(h, toText(node)))\n  }\n\n  h.inTable = true\n\n  const {headless, align} = inspect(node)\n  const rows = toRows(all(h, node), headless)\n  let columns = 1\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const colSpan = Number.parseInt(String(cell.data.colSpan), 10) || 1\n        const rowSpan = Number.parseInt(String(cell.data.rowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Dont add rows that dont exist.\n                // Browsers dont render them either.\n                break\n              }\n\n              /** @type {Array.<MdastRowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('colSpan' in cell.data) delete cell.data.colSpan\n        if ('rowSpan' in cell.data) delete cell.data.rowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  h.inTable = false\n\n  return h(node, 'table', {align}, rows)\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Element} node\n * @returns {Info}\n */\nfunction inspect(node) {\n  let headless = true\n  let rowIndex = 0\n  let cellIndex = 0\n  /** @type {Array.<string|null>} */\n  const align = [null]\n\n  visit(node, 'element', (child) => {\n    if (child.tagName === 'table' && node !== child) {\n      return SKIP\n    }\n\n    // If there is a `thead`, assume there is a header row.\n    if (cell(child) && child.properties) {\n      if (!align[cellIndex]) {\n        align[cellIndex] = String(child.properties.align || '') || null\n      }\n\n      // If there is a th in the first row, assume there is a header row.\n      if (headless && rowIndex < 2 && child.tagName === 'th') {\n        headless = false\n      }\n\n      cellIndex++\n    } else if (thead(child)) {\n      headless = false\n    } else if (tr(child)) {\n      rowIndex++\n      cellIndex = 0\n    }\n  })\n\n  return {align, headless}\n}\n\n/**\n * Ensure the rows are properly structured.\n *\n * @param {Array.<MdastNode>} children\n * @param {boolean} headless\n * @returns {Array.<MdastTableContent>}\n */\nfunction toRows(children, headless) {\n  let index = -1\n  /** @type {Array.<MdastTableContent>} */\n  const nodes = []\n  /** @type {Array.<MdastRowContent>|undefined} */\n  let queue\n\n  // Add an empty header row.\n  if (headless) {\n    nodes.push({type: 'tableRow', children: []})\n  }\n\n  while (++index < children.length) {\n    const node = children[index]\n\n    if (node.type === 'tableRow') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume row content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    nodes[nodes.length - 1].children.push(...queue)\n  }\n\n  index = -1\n\n  while (++index < nodes.length) {\n    nodes[index].children = toCells(nodes[index].children)\n  }\n\n  return nodes\n}\n\n/**\n * Ensure the cells in a row are properly structured.\n *\n * @param {Array.<MdastNode>} children\n * @returns {Array.<MdastRowContent>}\n */\nfunction toCells(children) {\n  /** @type {Array.<MdastRowContent>} */\n  const nodes = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n  /** @type {Array.<MdastPhrasingContent>|undefined} */\n  let queue\n\n  while (++index < children.length) {\n    node = children[index]\n\n    if (node.type === 'tableCell') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume phrasing content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    node = nodes[nodes.length - 1]\n\n    if (!node) {\n      node = {type: 'tableCell', children: []}\n      nodes.push(node)\n    }\n\n    node.children.push(...queue)\n  }\n\n  return nodes\n}\n","import {all} from '../all.js'\nimport {wrapChildren} from '../util/wrap-children.js'\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\nexport const handlers = {\n  root,\n  text,\n  comment,\n  doctype: ignore,\n\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  address: wrapChildren,\n  article: wrapChildren,\n  aside: wrapChildren,\n  body: wrapChildren,\n  center: wrapChildren,\n  div: wrapChildren,\n  fieldset: wrapChildren,\n  figcaption: wrapChildren,\n  figure: wrapChildren,\n  form: wrapChildren,\n  footer: wrapChildren,\n  header: wrapChildren,\n  hgroup: wrapChildren,\n  html: wrapChildren,\n  legend: wrapChildren,\n  main: wrapChildren,\n  multicol: wrapChildren,\n  nav: wrapChildren,\n  picture: wrapChildren,\n  section: wrapChildren,\n\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\nfunction ignore() {}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Root} Root\n */\n\nimport {all} from '../all.js'\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(h, node) {\n  let children = all(h, node)\n\n  if (h.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  return h(node, 'root', children)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Text} Text\n */\n\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(h, node) {\n  return h(node, 'text', wrapText(h, node.value))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Comment} Comment\n */\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Comment} node\n */\nexport function comment(h, node) {\n  return h(node, 'html', '<!--' + wrapText(h, node.value) + '-->')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function a(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(\n    node,\n    'link',\n    {\n      title: props.title || null,\n      url: resolve(h, String(props.href || '') || null)\n    },\n    all(h, node)\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function base(h, node) {\n  if (!h.baseFound) {\n    h.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || null\n    h.baseFound = true\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {wrapChildren} from '../util/wrap-children.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function blockquote(h, node) {\n  return h(node, 'blockquote', wrapChildren(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function br(h, node) {\n  return h.wrapText ? h(node, 'break') : h(node, 'text', ' ')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function hr(h, node) {\n  return h(node, 'thematicBreak')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function iframe(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  const src = String(props.src || '')\n  const title = String(props.title || '')\n\n  // Only create a link if there is a title.\n  // We cant use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (src && title) {\n    return {\n      type: 'link',\n      title: null,\n      url: resolve(h, src),\n      children: [{type: 'text', value: wrapText(h, title)}]\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function q(h, node) {\n  const expected = h.quotes[h.qNesting % h.quotes.length]\n\n  h.qNesting++\n  const contents = all(h, node)\n  h.qNesting--\n\n  contents.unshift({type: 'text', value: expected.charAt(0)})\n\n  contents.push({\n    type: 'text',\n    value: expected.length > 1 ? expected.charAt(1) : expected\n  })\n\n  return contents\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function select(h, node) {\n  const values = findSelectedOptions(h, node)\n  let index = -1\n  /** @type {Array.<string>} */\n  const results = []\n  /** @type {[string, string|null]} */\n  let value\n\n  while (++index < values.length) {\n    value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    return h(node, 'text', wrapText(h, results.join(', ')))\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function textarea(h, node) {\n  return h(node, 'text', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableRow(h, node) {\n  return h(node, 'tableRow', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function wbr(h, node) {\n  return h(node, 'text', '\\u200B')\n}\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Text} Text\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Context} Context\n * @typedef {import('./types.js').Properties} Properties\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').HWithoutProps} HWithoutProps\n * @typedef {import('./types.js').HWithProps} HWithProps\n * @typedef {import('./types.js').MdastNode} MdastNode\n * @typedef {import('./types.js').MdastRoot} MdastRoot\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {convert} from 'unist-util-is'\nimport {visit} from 'unist-util-visit'\nimport {one} from './one.js'\nimport {handlers} from './handlers/index.js'\nimport {own} from './util/own.js'\n\nexport {one} from './one.js'\nexport {all} from './all.js'\n\nconst block = convert(['heading', 'paragraph', 'root'])\n\n/**\n * @param {Node} tree\n * @param {Options} [options]\n */\nexport function toMdast(tree, options = {}) {\n  /** @type {Object.<string, Element>} */\n  const byId = {}\n  /** @type {MdastNode|MdastRoot} */\n  let mdast\n\n  /**\n   * @type {H}\n   */\n  const h = Object.assign(\n    /**\n     * @type {HWithProps & HWithoutProps}\n     */\n    (\n      /**\n       * @param {Node} node\n       * @param {string} type\n       * @param {Properties|string|Array.<Node>} [props]\n       * @param {string|Array.<Node>} [children]\n       */\n      (node, type, props, children) => {\n        /** @type {Properties|undefined} */\n        let properties\n\n        if (typeof props === 'string' || Array.isArray(props)) {\n          children = props\n          properties = {}\n        } else {\n          properties = props\n        }\n\n        /** @type {Node} */\n        // @ts-expect-error Assume valid `type` and `children`/`value`.\n        const result = {type, ...properties}\n\n        if (typeof children === 'string') {\n          // @ts-expect-error: Looks like a literal.\n          result.value = children\n        } else if (children) {\n          // @ts-expect-error: Looks like a parent.\n          result.children = children\n        }\n\n        if (node.position) {\n          result.position = node.position\n        }\n\n        return result\n      }\n    ),\n    {\n      nodeById: byId,\n      baseFound: false,\n      inTable: false,\n      wrapText: true,\n      /** @type {string|null} */\n      frozenBaseUrl: null,\n      qNesting: 0,\n      handlers: options.handlers\n        ? {...handlers, ...options.handlers}\n        : handlers,\n      document: options.document,\n      checked: options.checked || '[x]',\n      unchecked: options.unchecked || '[ ]',\n      quotes: options.quotes || ['\"']\n    }\n  )\n\n  visit(tree, 'element', (node) => {\n    const id =\n      node.properties &&\n      'id' in node.properties &&\n      String(node.properties.id).toUpperCase()\n\n    if (id && !own.call(byId, id)) {\n      byId[id] = node\n    }\n  })\n\n  // @ts-expect-error: does return a transformer, that does accept any node.\n  rehypeMinifyWhitespace({newlines: options.newlines === true})(tree)\n\n  const result = one(h, tree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    mdast = {type: 'root', children: result}\n  } else {\n    mdast = result\n  }\n\n  visit(mdast, 'text', ontext)\n\n  return mdast\n\n  /**\n   * Collapse text nodes, and fix whitespace.\n   * Most of this is taken care of by `rehype-minify-whitespace`, but\n   * were generating some whitespace too, and some nodes are in the end\n   * ignored.\n   * So clean up.\n   *\n   * @type {import('unist-util-visit/complex-types').BuildVisitor<MdastRoot, 'text'>}\n   */\n  function ontext(node, index, parent) {\n    /* c8 ignore next 3 */\n    if (index === null || !parent) {\n      return\n    }\n\n    const previous = parent.children[index - 1]\n\n    if (previous && previous.type === node.type) {\n      previous.value += node.value\n      parent.children.splice(index, 1)\n\n      if (previous.position && node.position) {\n        previous.position.end = node.position.end\n      }\n\n      // Iterate over the previous node again, to handle its total value.\n      return index - 1\n    }\n\n    node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n    // We dont care about other phrasing nodes in between (e.g., `[ asd ]()`),\n    // as there the whitespace matters.\n    if (parent && block(parent)) {\n      if (!index) {\n        node.value = node.value.replace(/^[\\t ]+/, '')\n      }\n\n      if (index === parent.children.length - 1) {\n        node.value = node.value.replace(/[\\t ]+$/, '')\n      }\n    }\n\n    if (!node.value) {\n      parent.children.splice(index, 1)\n      return index\n    }\n  }\n}\n\nexport {handlers as defaultHandlers} from './handlers/index.js'\n","/**\n * @typedef {import('hast-util-to-mdast').Options} Options\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new mdast\n * tree (bridge-mode).\n * Without destination, returns the mdast tree: further plugins run on that\n * tree (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `hast-util-to-mdast`.\n */\nconst rehypeRemark =\n  /**\n   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}\n   */\n  (\n    /**\n     * @param {Processor|Options} [destination]\n     * @param {Options} [options]\n     */\n    function (destination, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {Processor|undefined} */\n      let processor\n\n      if (typeof destination === 'function') {\n        processor = destination\n        settings = options || {}\n      } else {\n        settings = destination || {}\n      }\n\n      if (settings.document === undefined || settings.document === null) {\n        settings = Object.assign({}, settings, {document: true})\n      }\n\n      return processor ? bridge(processor, settings) : mutate(settings)\n    }\n  )\n\nexport default rehypeRemark\n\n/**\n * Bridge-mode.\n * Runs the destination with the new mdast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], HastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toMdast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further transformers run on the mdast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>}\n */\nfunction mutate(options = {}) {\n  return (node) => {\n    const result = /** @type {MdastRoot} */ (toMdast(node, options))\n    return result\n  }\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Context} Context\n */\n\n/**\n * @param {Context} base\n * @param {Options} extension\n * @returns {Context}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {string} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../util/indent-lines.js').Map} Map\n */\n\nimport {containerFlow} from '../util/container-flow.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Blockquote} node\n */\nexport function blockquote(node, _, context, safeOptions) {\n  const exit = context.enter('blockquote')\n  const tracker = track(safeOptions)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = indentLines(\n    containerFlow(node, context, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('mdast').Break} Break\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @type {Handle}\n * @param {Break} _\n */\nexport function hardBreak(_, _1, context, safe) {\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      context.unsafe[index].character === '\\n' &&\n      patternInScope(context.stack, context.unsafe[index])\n    ) {\n      return /[ \\t]/.test(safe.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Code} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, context) {\n  return Boolean(\n    !context.options.fences &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n * @typedef {import('../util/indent-lines.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Code} node\n */\nexport function code(node, _, context, safeOptions) {\n  const marker = checkFence(context)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, context)) {\n    const exit = context.enter('codeIndented')\n    const value = indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = track(safeOptions)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = context.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = context.enter('codeFencedLang' + suffix)\n    value += tracker.move(\n      safe(context, node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = context.enter('codeFencedMeta' + suffix)\n    value += tracker.move(' ')\n    value += tracker.move(\n      safe(context, node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['quote'], undefined>}\n */\nexport function checkQuote(context) {\n  const marker = context.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @type {Handle}\n * @param {Emphasis} node\n */\nexport function emphasis(node, _, context, safeOptions) {\n  const marker = checkEmphasis(context)\n  const exit = context.enter('emphasis')\n  const tracker = track(safeOptions)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Emphasis} _\n */\nfunction emphasisPeek(_, _1, context) {\n  return context.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['emphasis'], undefined>}\n */\nexport function checkEmphasis(context) {\n  const marker = context.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, context) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (context.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('../types.js').Handle} Handle\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @type {Handle}\n * @param {HTML} node\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @type {Handle}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nimage.peek = imagePeek\n\n/**\n * @type {Handle}\n * @param {Image} node\n */\nexport function image(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = context.enter('image')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('![')\n  value += tracker.move(\n    safe(context, node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @type {Handle}\n * @param {ImageReference} node\n */\nexport function imageReference(node, _, context, safeOptions) {\n  const type = node.referenceType\n  const exit = context.enter('imageReference')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('![')\n  const alt = safe(context, node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = safe(context, association(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, context) {\n  const raw = toString(node)\n\n  return Boolean(\n    !context.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nlink.peek = linkPeek\n\n/**\n * @type {Handle}\n * @param {Link} node\n */\nexport function link(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = track(safeOptions)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, context)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = context.stack\n    context.stack = []\n    exit = context.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      containerPhrasing(node, context, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    context.stack = stack\n    return value\n  }\n\n  exit = context.enter('link')\n  subexit = context.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Link} node\n */\nfunction linkPeek(node, _, context) {\n  return formatLinkAsAutolink(node, context) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @type {Handle}\n * @param {LinkReference} node\n */\nexport function linkReference(node, _, context, safeOptions) {\n  const type = node.referenceType\n  const exit = context.enter('linkReference')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('[')\n  const text = containerPhrasing(node, context, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = safe(context, association(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bulletOrdered'], undefined>}\n */\nexport function checkBulletOrdered(context) {\n  const marker = context.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['rule'], undefined>}\n */\nexport function checkRule(context) {\n  const marker = context.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @type {Handle}\n * @param {Strong} node\n */\nexport function strong(node, _, context, safeOptions) {\n  const marker = checkStrong(context)\n  const exit = context.enter('strong')\n  const tracker = track(safeOptions)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Strong} _\n */\nfunction strongPeek(_, _1, context) {\n  return context.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['strong'], undefined>}\n */\nexport function checkStrong(context) {\n  const marker = context.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['fence'], undefined>}\n */\nexport function checkFence(context) {\n  const marker = context.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `character` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} character\n *   Single character to look for.\n * @returns {number}\n *   Count of most frequent adjacent `character`s in `value`.\n */\nexport function longestStreak(value, character) {\n  const source = String(value)\n  let index = source.indexOf(character)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof character !== 'string' || character.length !== 1) {\n    throw new Error('Expected character')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + 1\n    index = source.indexOf(character, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {checkQuote} from '../util/check-quote.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Definition} node\n */\nexport function definition(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = context.enter('definition')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('[')\n  value += tracker.move(\n    safe(context, association(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Heading} node\n */\nexport function heading(node, _, context, safeOptions) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = track(safeOptions)\n\n  if (formatHeadingAsSetext(node, context)) {\n    const exit = context.enter('headingSetext')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = context.enter('headingAtx')\n  const subexit = context.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = containerPhrasing(node, context, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (context.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerFlow} from '../util/container-flow.js'\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @type {Handle}\n * @param {List} node\n */\nexport function list(node, parent, context, safeOptions) {\n  const exit = context.enter('list')\n  const bulletCurrent = context.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(context) : checkBullet(context)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(context)\n    : checkBulletOther(context)\n  const bulletLastUsed = context.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? context.options.bulletOrderedOther\n      : context.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      context.stack[context.stack.length - 1] === 'list' &&\n      context.stack[context.stack.length - 2] === 'listItem' &&\n      context.stack[context.stack.length - 3] === 'list' &&\n      context.stack[context.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      context.indexStack[context.indexStack.length - 1] === 0 &&\n      context.indexStack[context.indexStack.length - 2] === 0 &&\n      context.indexStack[context.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(context) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  context.bulletCurrent = bullet\n  const value = containerFlow(node, context, safeOptions)\n  context.bulletLastUsed = bullet\n  context.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bulletOrdered'], undefined>}\n */\nexport function checkBulletOrderedOther(context) {\n  const bulletOrdered = checkBulletOrdered(context)\n  const bulletOrderedOther = context.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bullet'], undefined>}\n */\nexport function checkBulletOther(context) {\n  const bullet = checkBullet(context)\n  const bulletOther = context.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerPhrasing} from '../util/container-phrasing.js'\n\n/**\n * @type {Handle}\n * @param {Paragraph} node\n */\nexport function paragraph(node, _, context, safeOptions) {\n  const exit = context.enter('paragraph')\n  const subexit = context.enter('phrasing')\n  const value = containerPhrasing(node, context, safeOptions)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerFlow} from '../util/container-flow.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(node, _, context, safeOptions) {\n  return containerFlow(node, context, safeOptions)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {safe} from '../util/safe.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(node, _, context, safeOptions) {\n  return safe(context, node.value, safeOptions)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @type {Handle}\n * @param {ThematicBreak} _\n */\nexport function thematicBreak(_, _1, context) {\n  const value = (\n    checkRule(context) + (context.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(context))\n\n  return context.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['ruleRepetition'], undefined>}\n */\nexport function checkRuleRepetition(context) {\n  const repetition = context.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, context) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, context) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, context)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? context.options.bulletOrderedOther\n      : context.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, context)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Context} Context\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').Unsafe} Unsafe\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\n\n/**\n * @param {Node} tree\n * @param {Options} [options]\n * @returns {string}\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {Context} */\n  // @ts-expect-error: well add `handle` later.\n  const context = {\n    enter,\n    stack: [],\n    unsafe: [],\n    join: [],\n    handlers: {},\n    options: {},\n    indexStack: []\n  }\n\n  configure(context, {unsafe, join, handlers: handle})\n  configure(context, options)\n\n  if (context.options.tightDefinitions) {\n    configure(context, {join: [joinDefinition]})\n  }\n\n  /** @type {Handle} */\n  context.handle = zwitch('type', {\n    invalid,\n    // @ts-expect-error: hush.\n    unknown,\n    // @ts-expect-error: hush.\n    handlers: context.handlers\n  })\n\n  let result = context.handle(tree, null, context, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Context['enter']} */\n  function enter(name) {\n    context.stack.push(name)\n    return exit\n\n    function exit() {\n      context.stack.pop()\n    }\n  }\n}\n\n/**\n * @type {Handle}\n * @param {unknown} value\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n","import remarkStringify from './lib/index.js'\n\nexport default remarkStringify\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/** @type {import('unified').Plugin<[Options]|void[], Node, string>} */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],"names":["Type","CompositeBlock","type","value","from","hash","end","children","positions","this","hashProp","NodeProp","child","pos","prop","Tree","length","push","nodeSet","last","Math","max","tree","types","balance","makeTree","NodeType","parentHash","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forwardInner","newPos","skipSpace","countIndent","charCodeAt","pop","to","findColumn","elt","i","goal","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","moveBase","space","ListItem","_cx","moveBaseColumn","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","scrub","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","finishContext","mark","reuseFragment","blockParsers","forward","leafBlockParsers","parse","lines","endLeafBlock","stop","finishLeaf","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","r","lineChunkAt","textOffset","nextFrom","scanLine","reset","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","getNodeType","none","addChild","toTree","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","blockNames","inlineParsers","inlineNames","wrappers","nodeTypes","Object","t","name","id","w","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","props","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","Parser","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","open","close","emp","closeSize","k","element","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","markdownHighlighting","tags","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","overlay","info","infoNode","getChild","StrikethroughDelim","Strikethrough","addDelimiter","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","TaskParser","GFM","parentType","parseSubSuper","addElement","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commonmark","configure","foldNodeProp","state","doc","lineAt","indentNodeProp","languageDataProp","mkLang","Language","commonmarkLanguage","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","support","language","ParseContext","load","nodeStart","sliceString","Context","spaceBefore","spaceAfter","item","number","String","itemNumber","getContext","context","replace","renumberList","changes","prev","insert","isMark","markdownKeymap","key","run","dispatch","syntaxTree","changeByRange","range","empty","isActiveAt","resolveInner","emptyLine","delTo","marker","EditorSelection","blank","lineBreak","prevLine","quoted","index","continued","charAt","update","scrollIntoView","userEvent","scan","childBefore","lastChild","contextNodeForDelete","spaceEnd","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","defaultCode","extensions","LanguageSupport","Prec","keymap","all","h","values","tagName","one","own","hasOwnProperty","wrapText","fn","properties","dataMdast","call","handlers","unknown","phrasing","convert","runs","head","wrapNeeded","onphrasing","onnonphrasing","queue","nonphrasing","identity","flattened","split","flatten","wrapChildren","frozenBaseUrl","findAfter","Number","POSITIVE_INFINITY","searchLineFeeds","searchTabOrSpaces","br","convertElement","cell","row","notRendered","Boolean","hidden","blockOrCaption","toText","results","options","whitespace","inferWhitespace","breakBefore","breakAfter","collectText","innerTextCollection","repeat","join","prefix","suffix","items","collectElement","collectPreText","lastIndex","trimAndCollapseSpacesAndTabs","noWrap","pre","isCode","code","classList","lang","className","meta","del","listItemsSpread","spread","wrapListItems","checked","div","dt","dd","handle","ordered","em","heading","img","src","alt","inlineCode","option","findSelectedOptions","findOptions","parseInt","multiple","selectedOptions","hasProperty","datalist","li","checkbox","clone","ol","list","source","video","media","poster","linkInFallbackContent","visit","EXIT","toString","strong","tableCell","rowSpan","colSpan","thead","tr","toCells","root","document","doctype","ignore","applet","area","basefont","bgsound","caption","col","colgroup","command","dialog","embed","frame","frameset","isindex","keygen","math","menu","menuitem","nextid","noembed","noframes","optgroup","param","script","shadow","spacer","svg","template","track","abbr","acronym","bdi","bdo","big","blink","button","canvas","cite","details","dfn","font","ins","marquee","meter","nobr","noscript","object","output","progress","rb","rbc","rp","rt","rtc","ruby","slot","small","span","sup","sub","tbody","tfoot","time","address","article","aside","body","center","fieldset","figcaption","figure","form","footer","header","hgroup","legend","main","multicol","nav","picture","section","href","audio","baseFound","blockquote","dir","dl","clean","groups","titles","definitions","h1","h2","h3","h4","h5","h6","hr","iframe","image","placeholder","texts","disabled","toUpperCase","nodeById","kbd","listing","plaintext","q","expected","quotes","qNesting","contents","samp","select","strike","summary","table","inTable","headless","rowIndex","cellIndex","align","SKIP","inspect","toRows","columns","cells","otherRowIndex","colIndex","newCells","alignIndex","td","textarea","th","tt","u","ul","var","wbr","xmp","toMdast","mdast","byId","position","unchecked","rehypeMinifyWhitespace","newlines","ontext","previous","destination","settings","processor","file","error","bridge","mutate","extension","hardBreak","_1","safe","unsafe","character","patternInScope","formatCodeAsIndented","fences","checkQuote","quote","emphasis","safeOptions","checkEmphasis","exit","enter","tracker","move","containerPhrasing","current","peek","formatHeadingAsSetext","literalWithBreak","setext","subexit","imageReference","referenceType","reference","association","formatLinkAsAutolink","raw","resourceLink","linkReference","checkBulletOrdered","bulletOrdered","checkRule","rule","checkStrong","shift","indentLines","containerFlow","break","fence","checkFence","sequence","longestStreak","encode","definition","rank","lastIndexOf","closeAtx","bulletCurrent","bullet","checkBullet","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","bulletLastUsed","useDifferentMarker","firstListItem","indexStack","listItem","paragraph","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","left","right","fullPhrasingSpans","inConstruct","notInConstruct","atBreak","invalid","joinDefinition","Compiler","tightDefinitions","zwitch","now","column","lineShift","toMarkdown"],"sourceRoot":""}