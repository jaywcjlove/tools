{"version":3,"file":"static/js/2355.bcca3525.chunk.js","mappings":"mKAAaA,EAAS,CACpBC,0BAA2B,CACzBC,OAAQ,yCACRC,YACE,uEACFC,KAAK,GAEPC,4BAA6B,CAC3BH,OAAQ,2CACRC,YAAa,+DAEfG,8BAA+B,CAC7BJ,OAAQ,+CACRC,YACE,8EAEJI,8BAA+B,CAC7BL,OAAQ,+CACRC,YACE,kFAEJK,2CAA4C,CAC1CN,OAAQ,+DACRC,YACE,wGAEJM,mBAAoB,CAClBP,OAAQ,mCACRC,YACE,kGAEJO,sCAAuC,CACrCR,OAAQ,iDACRC,YACE,8HAEJQ,sCAAuC,CACrCT,OAAQ,kDACRC,YACE,mEACFC,KAAK,GAEPQ,8BAA+B,CAC7BV,OAAQ,+BACRC,YACE,mGAEJU,0BAA2B,CACzBX,OAAQ,yCACRC,YACE,6GAEJW,kCAAmC,CACjCZ,OAAQ,qDACRC,YACE,6EACFC,KAAK,GAEPW,mBAAoB,CAClBb,OAAQ,iCACRC,YACE,yEAEJa,qBAAsB,CACpBd,OAAQ,sCACRC,YAAa,8CAEfc,0BAA2B,CACzBf,OAAQ,yCACRC,YAAa,2CAEfe,iCAAkC,CAChChB,OAAQ,8BACRC,YAAa,6DACbC,KAAK,GAEPe,iBAAkB,CAChBjB,OAAQ,yBACRC,YAAa,qDAEfiB,WAAY,CACVlB,OAAQ,kCACRC,YAAa,6DAEfkB,aAAc,CACZnB,OAAQ,oCACRC,YAAa,kEAEfmB,aAAc,CACZpB,OAAQ,oCACRC,YACE,gFAEJoB,mCAAoC,CAClCrB,OAAQ,+DACRC,YAAa,yDACbC,KAAK,GAEPoB,+BAAgC,CAC9BtB,OAAQ,kDACRC,YAAa,kEAEfsB,SAAU,CACRvB,OAAQ,gCACRC,YAAa,yDAEfuB,yBAA0B,CACxBxB,OAAQ,6BACRC,YAAa,6DAEfwB,yBAA0B,CACxBzB,OAAQ,6BACRC,YAAa,2DAEfyB,yCAA0C,CACxC1B,OAAQ,sCACRC,YAAa,8DAEf0B,+BAAgC,CAC9B3B,OAAQ,sCACRC,YAAa,qDAEf2B,iBAAkB,CAChB5B,OAAQ,oBACRC,YAAa,mDACbC,KAAK,GAEP2B,gCAAiC,CAC/B7B,OAAQ,+BACRC,YACE,0EACFC,KAAK,GAEP4B,sBAAuB,CACrB9B,OAAQ,0BACRC,YACE,uEAEJ8B,eAAgB,CACd/B,OAAQ,uCACRC,YAAa,oDACbC,KAAK,GAEP8B,mBAAoB,CAClBhC,OAAQ,uBACRC,YAAa,2DAEfgC,+BAAgC,CAC9BjC,OAAQ,uCACRC,YAAa,6DAEfiC,+BAAgC,CAC9BlC,OAAQ,uCACRC,YACE,kGAEJkC,kBAAmB,CACjBnC,OAAQ,0BACRC,YAAa,qDAEfmC,0CAA2C,CACzCpC,OAAQ,oDACRC,YAAa,iDAEfoC,0CAA2C,CACzCrC,OAAQ,oDACRC,YAAa,iDAEfqC,wCAAyC,CACvCtC,OAAQ,8CACRC,YAAa,yCAEfsC,2CAA4C,CAC1CvC,OAAQ,wDACRC,YAAa,sDAEfuC,2CAA4C,CAC1CxC,OAAQ,wDACRC,YAAa,sDAEfwC,mCAAoC,CAClCzC,OAAQ,yCACRC,YAAa,sDAEfyC,mCAAoC,CAClC1C,OAAQ,wCACRC,YAAa,sDAEf0C,0DAA2D,CACzD3C,OACE,sEACFC,YAAa,sDAEf2C,cAAe,CACb5C,OAAQ,4BACRC,YAAa,2CAEf4C,qBAAsB,CACpB7C,OAAQ,6CACRC,YACE,oEACFC,KAAK,GAEP4C,qBAAsB,CACpB9C,OAAQ,gDACRC,YACE,+EACFC,KAAK,GAEP6C,8CAA+C,CAC7C/C,OAAQ,6DACRC,YAAa,wCAEf+C,+BAAgC,CAC9BhD,OACE,uEACFC,YAAa,2DAEfgD,0BAA2B,CACzBjD,OAAQ,oCACRC,YAAa,gEAEfiD,uBAAwB,CACtBlD,OAAQ,8DACRC,YAAa,6DAEfkD,yBAA0B,CACxBnD,OAAQ,yBACRC,YAAa,uDACbC,KAAK,GAEPkD,4BAA6B,CAC3BpD,OAAQ,mEACRC,YACE,uEAEJoD,uBAAwB,CACtBrD,OAAQ,iCACRC,YACE,4EAEJqD,gDAAiD,CAC/CtD,OAAQ,uDACRC,YAAa,8CAEfsD,mCAAoC,CAClCvD,OAAQ,yCACRC,YACE,oFAEJuD,4CAA6C,CAC3CxD,OAAQ,mDACRC,YAAa,4DAEfwD,wCAAyC,CACvCzD,OAAQ,+CACRC,YAAa,oDAEfyD,wBAAyB,CACvB1D,OAAQ,4BACRC,YACE,kEAEJ0D,uCAAwC,CACtC3D,OAAQ,+CACRC,YAAa,qDAEf2D,uBAAwB,CACtB5D,OAAQ,0BACRC,YACE,iFAEJ4D,+BAAgC,CAC9B7D,OAAQ,+CACRC,YACE,8ECjPA6D,EAAO,mEAEPC,EAAa,CAAC,GAAG,EAAM,GAAG,EAAO,EAAG,MAG3B,SAASC,EAAYC,GAClC,IAAMC,EAA4CC,KAAKC,KAAK,YACtDC,EAAWC,OAAOC,OAAO,CAAC,EAAGL,EAAmBD,GAEtDK,OAAOC,OAAOJ,KAAM,CAACK,OAGrB,SAAgBC,EAAKC,GACnB,IAAMC,EAAKN,EAASO,SAAW,gBAAkB,QAC3CC,EAAeR,EAASS,gBAkB9B,SAAiBC,GACf,IAAMC,EAAOD,EAAMC,KACbC,GAmDOC,EAnDUF,EAqDpBE,EAAMC,QAAQ,WAAW,SAACC,GAAD,OAAQA,EAAGC,OAAO,GAAGC,aAArB,KApDtBC,EAAUlB,EAASY,GACnBO,OAAqBC,IAAZF,GAAqC,OAAZA,GAA0BA,EAC5DG,EAA0B,kBAAXF,EAAsBA,EAASA,EAAS,EAAI,EAC3DG,EAAQ,CACZC,KAAMb,EAAMc,UACZC,OAAQf,EAAMgB,SACdC,OAAQjB,EAAMkB,aAEVC,EAAM,CACVN,KAAMb,EAAMoB,QACZL,OAAQf,EAAMqB,OACdJ,OAAQjB,EAAMsB,WAuCtB,IAAmBnB,EArCb,GAAIQ,EAAO,CAET,IAAMY,EAAOxG,EAAOmF,IAAS,CAACjF,OAAQ,GAAIC,YAAa,GAAIC,IAAK,IAC1DqG,EAAU7B,EAAK6B,QAAQC,EAAOF,EAAKtG,QAAS,CAAC2F,MAAAA,EAAOO,IAAAA,IAC1DK,EAAQE,OAAS,cACjBF,EAAQG,OAAS1B,EACjBuB,EAAQI,MAAQ5C,EAAW2B,GAC3Ba,EAAQK,KAAOJ,EAAOF,EAAKrG,aAC3BsG,EAAQrG,IAAM,QAASoG,IAAqB,IAAbA,EAAKpG,IAAgB,KAAO4D,EAAOkB,CACnE,CAMD,SAASwB,EAAOtB,GACd,OAAOA,EACJC,QAAQ,kBAAkB,SAAC0B,EAAyBC,GACnD,IAAMd,EAASc,GAAMC,OAAOC,SAASF,EAAI,IAAM,EACzCG,EAAOxC,EAAIY,OAAON,EAAMkB,YAAcD,GAC5C,MAAgB,MAATiB,EAAe,QAAUA,CACjC,IACA9B,QACC,OACA,iBACE,KACAV,EAAIyC,WAAWnC,EAAMkB,aAAakB,SAAS,IAAI7B,aAFjD,GAIL,CACF,EA/DyD,KACpD8B,EAAS,IAAIC,EAAQ,CACzBC,wBAAwB,EACxBzC,aAAAA,EACA0C,kBAAkB,IAKpB,OAAOC,EAAAA,EAAAA,GAAWJ,EAAOzC,GAAIF,GAAM,CACjCgD,MAAOpD,EAASoD,MAChB/C,KAAAA,EACAgD,QAASrD,EAASqD,SAoDrB,GACF,C,iHCpGM,SAASC,EAAIC,EAAGC,GAarB,IAVA,IAAMC,EAAQD,EAAOE,UAAY,GAE3BC,EAAS,GACXC,GAAS,EACTC,EAASJ,EAAMI,OACfC,EAAQL,EAAMG,EAAQ,GAKnBE,GAAwB,YAAfA,EAAMC,MAAwC,OAAlBD,EAAME,SAEhDF,EAAQL,IADRG,EACsB,GAKxB,IAFAE,EAAQL,EAAMI,EAAS,GAGrBA,EAAS,EAAID,GACbE,GACe,YAAfA,EAAMC,MACY,OAAlBD,EAAME,SAGNF,EAAQL,IADRI,EACuB,GAGzB,OAASD,EAAQC,GAAQ,CAEvB,IAAMI,EAASC,EAAIX,EAAGE,EAAMG,GAAQJ,GAEhCW,MAAMC,QAAQH,GAChBN,EAAOU,KAAP,MAAAV,GAAM,OAASM,IACNA,GACTN,EAAOU,KAAKJ,EAEf,CAED,OAAON,CACR,CCvDM,IAAMW,EAAM,CAAC,EAAEC,eCSf,SAASC,EAASjB,EAAG1C,GAC1B,OAAO0C,EAAEiB,SAAW3D,EAAQA,EAAMC,QAAQ,YAAa,IACxD,CCOM,SAASoD,EAAIX,EAAGkB,EAAMjB,GAE3B,IAAIlD,EAEJ,GAAkB,YAAdmE,EAAKV,KAAoB,CAC3B,GAAIU,EAAKC,YAA4C,WAA9BD,EAAKC,WAAWC,UACrC,OAGEL,EAAIM,KAAKrB,EAAEsB,SAAUJ,EAAKT,WAC5B1D,EAAKiD,EAAEsB,SAASJ,EAAKT,SAExB,MAAUM,EAAIM,KAAKrB,EAAEsB,SAAUJ,EAAKV,QACnCzD,EAAKiD,EAAEsB,SAASJ,EAAKV,OAGvB,MAAkB,oBAAPzD,EACFA,EAAGiD,EAAGkB,EAAMjB,GAUvB,SAAiBD,EAAGkB,GAElB,GAA0B,kBAAfA,EAAK5D,MAEd,OAAO0C,EAAEkB,EAAM,OAAQD,EAASjB,EAAGkB,EAAK5D,QAG1C,OAAOyC,EAAIC,EAAGkB,EACf,CAfQK,CAAQvB,EAAGkB,EACnB,C,oCC5BYM,GAAWC,EAAAA,EAAAA,GAAQ,CAC9B,QACA,SACA,WACA,WACA,oBACA,QACA,iBACA,aACA,OACA,gBACA,SACA,S,8BCXK,SAASC,EAAKxB,GACnB,OAAOyB,EAAKzB,GAMZ,SAAoBA,GAClB,IAAM0B,EAAO1B,EAAM,GAEnB,GACmB,IAAjBA,EAAMI,QACQ,SAAdsB,EAAKpB,OACW,MAAfoB,EAAKtE,OAAgC,OAAfsE,EAAKtE,OAE5B,MAAO,GAGT,MAAO,CAACkD,KAAM,YAAaL,SAAUD,EACtC,GACF,CAUM,SAAS2B,EAAW3B,GAKzB,IAJA,IAEIgB,EAFAb,GAAS,IAIJA,EAAQH,EAAMI,QAGrB,IAAKkB,EAFLN,EAAOhB,EAAMG,KAEW,aAAca,GAAQW,EAAWX,EAAKf,UAC5D,OAAO,EAIX,OAAO,CACR,CASD,SAASwB,EAAKzB,EAAO4B,EAAYC,GAY/B,IAXA,IAOIC,EAEAd,EATEe,EAAcF,GAAiBG,EAE/BC,EAsCR,SAAiBjC,GAEf,IAGIgB,EAHAiB,EAAY,GACZ9B,GAAS,EAIb,OAASA,EAAQH,EAAMI,QAaJ,YAZjBY,EAAOhB,EAAMG,IAYLG,MAAmC,SAAdU,EAAKV,OAChCqB,EAAWX,EAAKf,UAIhBgC,EAAUrB,KAAKI,GAFfiB,EAAYA,EAAUC,OAAOC,EAAMnB,IAMvC,OAAOiB,CACR,CApEmBG,CAAQpC,GAEtBQ,EAAS,GACTL,GAAS,IAMJA,EAAQ8B,EAAU7B,QAGrBkB,EAFJN,EAAOiB,EAAU9B,KAGV2B,IAAOA,EAAQ,IACpBA,EAAMlB,KAAKI,KAEPc,IACFtB,EAASA,EAAO0B,OAAON,EAAWE,IAClCA,OAAQnE,GAGV6C,EAASA,EAAO0B,OAAOH,EAAYf,KAQvC,OAJIc,IACFtB,EAASA,EAAO0B,OAAON,EAAWE,KAG7BtB,CACR,CA4CD,SAAS2B,EAAMnB,GAEb,OAAOS,EAAKT,EAAKf,UA6BjB,SAAoBD,GAEUgB,EAArBf,SAAP,IAAoBoC,GAApB,OAA4BrB,EAA5B,GAEA,OAAO,kBAAIsB,GAAO,EAAM,CAAC,EAAGD,IAA5B,IAAmCpC,SAAUD,GAC9C,IAxBD,SAAuBK,GACrB,GAAI,aAAcA,GAAS,aAAcW,EAAM,CACjBA,EAArBf,SAAP,IAAoBoC,GAApB,OAA4BrB,EAA5B,GACA,OAAO,kBACFX,GADL,IAGEJ,SAAU,EAAC,kBAAIqC,GAAO,EAAM,CAAC,EAAGD,IAAtB,IAA6BpC,SAAUI,EAAMJ,aAE1D,CAED,OAAO,UAAII,EACZ,GAcF,CAUD,SAASiB,EAASN,GAChB,OAAOA,EAAK1E,MAAQ0E,EAAK1E,KAAKiG,OAC1BC,EAAAA,EAAAA,GAAa,CACXlC,KAAM,UACNC,QAASS,EAAK1E,KAAKiG,MACnBtB,WAAY,CAAC,EACbhB,SAAU,KAEZwC,EAAczB,EACnB,CAOD,SAASgB,EAASU,GAChB,OAAOA,CACR,CCjMM,SAASC,EAAa7C,EAAGkB,GAC9B,OAAOQ,EAAK3B,EAAIC,EAAGkB,GACpB,CCPM,SAAS4B,EAAQ9C,EAAG1H,GACzB,OAAY,OAARA,QAAwBuF,IAARvF,EACX,GAGL0H,EAAE+C,cACGC,OAAO,IAAIC,IAAI3K,EAAK0H,EAAE+C,gBAGxBzK,CACR,C,eCRU4K,EAcP,SAAUjD,EAAQI,EAAO8C,GACvB,IAAIC,GAAK3B,EAAAA,EAAAA,GAAQ0B,GAEjB,IAAKlD,IAAWA,EAAOO,OAASP,EAAOE,SACrC,MAAM,IAAIkD,MAAM,wBAGlB,GAAqB,kBAAVhD,GACT,GAAIA,EAAQ,GAAKA,IAAUlB,OAAOmE,kBAChC,MAAM,IAAID,MAAM,iDAKlB,IAFAhD,EAAQJ,EAAOE,SAASoD,QAAQlD,IAEpB,EACV,MAAM,IAAIgD,MAAM,gCAIpB,OAAShD,EAAQJ,EAAOE,SAASG,QAC/B,GAAI8C,EAAGnD,EAAOE,SAASE,GAAQA,EAAOJ,GACpC,OAAOA,EAAOE,SAASE,GAI3B,OAAO,IACR,ECnBCmD,EAAkB,MAClBC,EAAoB,UAEpBC,GAAKC,EAAAA,EAAAA,GAAe,MACpBC,GAAID,EAAAA,EAAAA,GAAe,KACnBE,GAAOF,EAAAA,EAAAA,GAAe,CAAC,KAAM,OAC7BG,GAAMH,EAAAA,EAAAA,GAAe,MAIrBI,GAAcJ,EAAAA,EAAAA,GAAe,CAEjC,WACA,OACA,UACA,WACA,WACA,KACA,SACA,QACA,WACA,QA0dF,SAAgBzC,GACd,OAAO8C,SAAS9C,EAAKC,YAAc,CAAC,GAAG8C,OACxC,EAGD,SAAsB/C,GACpB,MAAwB,WAAjBA,EAAKT,WAA0BS,EAAKC,YAAc,CAAC,GAAG+C,IAC9D,IAzdKC,GAAiBR,EAAAA,EAAAA,GAAe,CACpC,UACA,UACA,QACA,aACA,OACA,UACA,SACA,KACA,SACA,MACA,KACA,KACA,MACA,SACA,aACA,SACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,SACA,KACA,OACA,SACA,UACA,OACA,OACA,MACA,KACA,IACA,YACA,MACA,UACA,KACA,QAaK,SAASS,EAAOlD,GAAoB,IAYrCmD,EAEA/G,EAEAgH,EAhBuBjI,EAAc,uDAAJ,CAAC,EAGhC8D,EAAWe,EAAKf,UAAY,GAC5BoE,EAAQJ,EAAejD,GACvBsD,EAAaC,EAAgBvD,EAAM,CACvCsD,WAAYnI,EAAQmI,YAAc,SAClCE,aAAa,EACbC,YAAY,IAEVtE,GAAS,EAgBb,GAAkB,SAAda,EAAKV,MAAiC,YAAdU,EAAKV,KAC/B,OAAOoE,EAAY1D,EAAM,CAACsD,WAAAA,EAAYE,aAAa,EAAMC,YAAY,IAiBvE,IAHAN,EAAU,KAGDhE,EAAQF,EAASG,QAMxB+D,EAAUA,EAAQjC,OAEhByC,EAAoB1E,EAASE,GAAQa,EAAM,CACzCsD,WAAAA,EACAE,YAAarE,EAAQ,KAAOkE,EAC5BI,WACEtE,EAAQF,EAASG,OAAS,EAAIoD,EAAGvD,EAASE,EAAQ,IAAMkE,KAYhElE,GAAS,EAIT,IAFA,IAAMK,EAAS,KAENL,EAAQgE,EAAQ/D,QAGF,kBAFrBhD,EAAQ+G,EAAQhE,SAGAxC,IAAVyG,GAAuBhH,EAAQgH,IAAOA,EAAQhH,GACzCA,IACLgH,GAAO5D,EAAOI,KAAK,KAAKgE,OAAOR,IACnCA,EAAQ,EACR5D,EAAOI,KAAKxD,IAKhB,OAAOoD,EAAOqE,KAAK,GACpB,CAUD,SAASF,EAAoB3D,EAAMjB,EAAQ5D,GACzC,MAAkB,YAAd6E,EAAKV,KAsBX,SAAwBU,EAAMjB,EAAQ5D,GAEpC,IAMI2I,EAEAC,EARET,EAAaC,EAAgBvD,EAAM7E,GACnC8D,EAAWe,EAAKf,UAAY,GAC9BE,GAAS,EAET6E,EAAQ,GAQZ,GAAInB,EAAY7C,GACd,OAAOgE,EAmBLxB,EAAGxC,IAYE4C,EAAI5C,IAASgC,EAAUjD,EAAQiB,EAAM4C,GAX5CmB,EAAS,KAiBFrB,EAAE1C,IACT8D,EAAS,EACTC,EAAS,GAMFd,EAAejD,KACtB8D,EAAS,EACTC,EAAS,GAMX,OAAS5E,EAAQF,EAASG,QACxB4E,EAAQA,EAAM9C,OACZyC,EAAoB1E,EAASE,GAAQa,EAAM,CACzCsD,WAAAA,EACAE,YAAarE,OAAQxC,EAAYmH,EACjCL,WACEtE,EAAQF,EAASG,OAAS,EAAIoD,EAAGvD,EAASE,EAAQ,IAAM4E,KAW5DpB,EAAK3C,IAASgC,EAAUjD,EAAQiB,EAAM2C,IACxCqB,EAAMpE,KAAK,MAITkE,GAAQE,EAAMC,QAAQH,GACtBC,GAAQC,EAAMpE,KAAKmE,GAEvB,OAAOC,CACR,CAnHUE,CAAelE,EAAMjB,EAAQ5D,GAGpB,SAAd6E,EAAKV,KACA,CACkB,WAAvBnE,EAAQmI,WACJI,EAAY1D,EAAM7E,GAClBgJ,EAAenE,IAIhB,EACR,CA8HD,SAAS0D,EAAY1D,EAAM7E,GAezB,IAdA,IAQIiJ,EAEAhH,EAEAyG,EAZEzH,EAAQ0F,OAAO9B,EAAK5D,OAEpBiI,EAAQ,GAER7E,EAAS,GACX3C,EAAQ,EACRsC,GAAS,EAQNtC,EAAQT,EAAMgD,QACnBkD,EAAgBgC,UAAYzH,EAG5BO,GAFAgH,EAAQ9B,EAAgBiC,KAAKnI,IAEfgI,EAAMjF,MAAQ/C,EAAMgD,OAElCiF,EAAMzE,KAGJ4E,EAIEpI,EACGqI,MAAM5H,EAAOO,GACbf,QAAQ,kDAAmD,IAC9DlB,EAAQqI,YACRrI,EAAQsI,aAIZ5G,EAAQO,EAAM,EAQhB,OAAS+B,EAAQkF,EAAMjF,QAKkC,OAArDiF,EAAMlF,GAAOf,WAAWiG,EAAMlF,GAAOC,OAAS,IAC7CD,EAAQkF,EAAMjF,OAAS,GACa,OAAnCiF,EAAMlF,EAAQ,GAAGf,WAAW,IAE9BoB,EAAOI,KAAKyE,EAAMlF,IAClB0E,EAAO,IAmBAQ,EAAMlF,KACT0E,GAAMrE,EAAOI,KAAKiE,GACtBrE,EAAOI,KAAKyE,EAAMlF,IAClB0E,EAAO,KAIX,OAAOrE,EAAOqE,KAAK,GACpB,CAMD,SAASM,EAAenE,GACtB,OAAO8B,OAAO9B,EAAK5D,MACpB,CAeD,SAASoI,EAA6BpI,EAAOoH,EAAaC,GASxD,IAPA,IAGIW,EAEAhH,EALEoC,EAAS,GACX3C,EAAQ,EAMLA,EAAQT,EAAMgD,QACnBmD,EAAkB+B,UAAYzH,EAG9BO,GAFAgH,EAAQ7B,EAAkBgC,KAAKnI,IAEjBgI,EAAMjF,MAAQ/C,EAAMgD,OAI7BvC,GAAUO,IAAOgH,GAAUZ,GAC9BhE,EAAOI,KAAK,IAGV/C,IAAUO,GACZoC,EAAOI,KAAKxD,EAAMqI,MAAM5H,EAAOO,IAGjCP,EAAQuH,EAAQhH,EAAMgH,EAAM,GAAGhF,OAAShC,EAW1C,OAJIP,IAAUO,GAAQqG,GACpBjE,EAAOI,KAAK,IAGPJ,EAAOqE,KAAK,IACpB,CASD,SAASN,EAAgBvD,EAAM7E,GAE7B,IAAIuJ,EAEJ,GAAkB,YAAd1E,EAAKV,KAEP,OADAoF,EAAQ1E,EAAKC,YAAc,CAAC,EACpBD,EAAKT,SACX,IAAK,UACL,IAAK,YACL,IAAK,MACH,MAAO,MACT,IAAK,OACH,MAAO,SACT,IAAK,MACH,OAAOmF,EAAMlE,KAAO,WAAa,MACnC,IAAK,KACL,IAAK,KACH,OAAOkE,EAAMC,OAAS,SAAWxJ,EAAQmI,WAC3C,IAAK,WACH,MAAO,WAKb,OAAOnI,EAAQmI,UAChB,CCjgBD,IAAMQ,EAAS,YAETc,GAAMnC,EAAAA,EAAAA,GAAe,OACrBoC,GAASpC,EAAAA,EAAAA,GAAe,QAMvB,SAASvG,EAAK4C,EAAGkB,GACtB,IAGI8E,EAEAC,ECpB4B3I,EDe1B6C,EAAWe,EAAKf,SAClBE,GAAS,EAMb,GAAIyF,EAAI5E,GACN,OAASb,EAAQF,EAASG,QAAQ,CAChC,IAAMC,EAAQJ,EAASE,GAEvB,GACE0F,EAAOxF,IACPA,EAAMY,YACNZ,EAAMY,WAAW+E,WACjBtF,MAAMC,QAAQN,EAAMY,WAAW+E,WAC/B,CACAF,EAAYzF,EAAMY,WAAW+E,UAC7B,KACD,CACF,CAGH,GAAIF,EAGF,IAFA3F,GAAS,IAEAA,EAAQ2F,EAAU1F,QACzB,GAAI0C,OAAOgD,EAAU3F,IAAQsF,MAAM,EAAGX,EAAO1E,UAAY0E,EAAQ,CAC/DiB,EAAOjD,OAAOgD,EAAU3F,IAAQsF,MAAMX,EAAO1E,QAC7C,KACD,CAIL,OAAON,EACLkB,EACA,OACA,CAAC+E,KAAMA,GAAQ,KAAME,KAAM,OCpDG7I,EDqDZ2D,EAASjB,EAAGoE,EAAOlD,ICpDhC8B,OAAO1F,GAAOC,QAAQ,OAAQ,KDsDtC,CElDM,SAAS6I,EAAIpG,EAAGkB,GACrB,OAAOlB,EAAEkB,EAAM,SAAUnB,EAAIC,EAAGkB,GACjC,CCLM,SAASmF,EAAgBlG,GAC9B,IAAIE,GAAS,EAEb,GAAIF,EAASG,OAAS,EACpB,OAASD,EAAQF,EAASG,QACxB,GAAIH,EAASE,GAAOiG,OAClB,OAAO,EAKb,OAAO,CACR,CCPM,SAASC,EAAcvG,EAAGkB,GAI/B,IAHA,IAAMf,EAAWJ,EAAIC,EAAGkB,GACpBb,GAAS,IAEJA,EAAQF,EAASG,QAAQ,CAChC,IAAMC,EAAQJ,EAASE,GACJ,aAAfE,EAAMC,OACRL,EAASE,GAAS,CAChBG,KAAM,WACN8F,QAAQ,EACRE,QAAS,KAETrG,SAAU,CAACI,IAGhB,CAGD,OAAOJ,CACR,CCbD,IAAMsG,GAAM9C,EAAAA,EAAAA,GAAe,OACrB+C,GAAK/C,EAAAA,EAAAA,GAAe,MACpBgD,GAAKhD,EAAAA,EAAAA,GAAe,MAmF1B,SAASiD,EAAO5G,EAAGG,GACjB,IAAMD,EAAQqG,EAAcvG,EAAG,CAACQ,KAAM,UAAWC,QAAS,IAAKN,SAAAA,IAE/D,OAAqB,IAAjBD,EAAMI,OACD,GAGY,IAAjBJ,EAAMI,OACDJ,EAAM,GAAGC,SAGX,CACL,CACEK,KAAM,OACNqG,SAAS,EACT9I,MAAO,KACPuI,OAAQD,EAAgBnG,GACxBC,SAAUD,GAGf,CCjHM,SAAS4G,EAAG9G,EAAGkB,GACpB,OAAOlB,EAAEkB,EAAM,WAAYnB,EAAIC,EAAGkB,GACnC,CCDM,SAAS6F,GAAQ/G,EAAGkB,GAGzB,IAAM8F,EAAQ7H,OAAO+B,EAAKT,QAAQhD,OAAO,KAAO,EAC1CiE,EAAO1B,EAAEiB,SAEfjB,EAAEiB,UAAW,EACb,IAAMP,EAASV,EAAEkB,EAAM,UAAW,CAAC8F,MAAAA,GAAQjH,EAAIC,EAAGkB,IAGlD,OAFAlB,EAAEiB,SAAWS,EAENhB,CACR,CCXM,SAASuG,GAAIjH,EAAGkB,GAGrB,IAAM0E,EAAQ1E,EAAKC,WACnB,OAAOnB,EAAEkB,EAAM,QAAS,CACtB5I,IAAKwK,EAAQ9C,EAAGgD,OAAO4C,EAAMsB,KAAO,KAAO,MAC3CC,MAAOvB,EAAMuB,OAAS,KACtBC,IAAKxB,EAAMwB,KAAO,IAErB,CCTM,SAASC,GAAWrH,EAAGkB,GAC5B,OAAOlB,EAAEkB,EAAM,aAAcD,EAASjB,EAAGoE,EAAOlD,IACjD,C,gBCDKoG,IAAS3D,EAAAA,EAAAA,GAAe,UAQvB,SAAS4D,GAAoBvH,EAAGkB,EAAMC,GAc3C,IAXA,IAAMyE,EAAQzE,GAAcD,EAAKC,WAC7B9E,EAAUmL,GAAYtG,GACpBuG,EACJC,KAAKC,IAAIxI,OAAOC,SAAS4D,OAAO4C,EAAM6B,MAAO,IAAK,KACjD7B,EAAMgC,SAAW,EAAI,GACpBvH,GAAS,EAEPwH,EAAkB,GAElBzH,EAAS,KAENC,EAAQhE,EAAQiE,SACnBwH,EAAAA,GAAAA,GAAYzL,EAAQgE,GAAQ,aAC9BwH,EAAgB/G,KAAKzE,EAAQgE,IAQjC,IAHAhE,GADawL,EAAgBvH,OAAS,EAAIuH,EAAkBxL,GAC7CsJ,MAAM,EAAG8B,GACxBpH,GAAS,IAEAA,EAAQhE,EAAQiE,QAAQ,CAC/B,IAAMgH,EAASjL,EAAQgE,GACjB0H,EAAU9G,EAASjB,EAAGoE,EAAOkD,IAG7B1B,EAAQ0B,EAAOnG,WACf6G,EAAQD,GAAW/E,OAAO4C,EAAMoC,OAAS,IACzC1K,EAAQ0F,OAAO4C,EAAMtI,OAAS,KAAOyK,EAC3C3H,EAAOU,KAAK,CAACxD,EAAO0K,IAAU1K,EAAQ,KAAO0K,GAC9C,CAED,OAAO5H,CACR,CAKD,SAASoH,GAAYtG,GAQnB,IAPA,IAKIX,EALEJ,EAAWe,EAAKf,SAClBE,GAAS,EAETgE,EAAU,KAILhE,EAAQF,EAASG,QACxBC,EAAQJ,EAASE,GAGbO,MAAMC,QAAQN,EAAMJ,YAEtBkE,EAAUA,EAAQjC,OAAOoF,GAAYjH,KAGnC+G,GAAO/G,MAAWuH,EAAAA,GAAAA,GAAYvH,EAAO,aACvC8D,EAAQvD,KAAKP,GAIjB,OAAO8D,CACR,CCxED,IAAM4D,IAAWtE,EAAAA,EAAAA,GAAe,YCHhC,IAAMC,IAAID,EAAAA,EAAAA,GAAe,KACnBuE,IAAQvE,EAAAA,EAAAA,GAAe,SAMtB,SAASwE,GAAGnI,EAAGkB,GACpB,IAIIkH,EAEAC,EANEzG,EAAOV,EAAKf,SAAS,GAEvBqG,EAAU,KAOV5C,GAAEhC,KACJwG,EAAWxG,EAAKzB,SAAS,GAGvB+H,GAAME,IACNA,EAASjH,aACqB,aAA7BiH,EAASjH,WAAWX,MACU,UAA7B4H,EAASjH,WAAWX,QAEtBgG,EAAUxC,QAAQoE,EAASjH,WAAWqF,SACtC6B,GAAQ,kBACHnH,GADA,IAEHf,SAAU,EAAC,kBACLyB,GADE,IACIzB,SAAUyB,EAAKzB,SAASwF,MAAM,MADlC,eAEHzE,EAAKf,SAASwF,MAAM,SAM/B,IAAMoC,EAAUlF,EAAa7C,EAAGqI,GAASnH,GAEzC,OAAOlB,EAAEkB,EAAM,WAAY,CAACoF,OAAQyB,EAAQzH,OAAS,EAAGkG,QAAAA,GAAUuB,EACnE,CCxCD,IAAMO,IAAK3E,EAAAA,EAAAA,GAAe,MAMnB,SAAS4E,GAAKvI,EAAGkB,GACtB,IAAM2F,EAAUyB,GAAGpH,GACbf,EAAWoG,EAAcvG,EAAGkB,GAE9BnD,EAAQ,KASZ,OAPI8I,IACF9I,GAAQ+J,EAAAA,GAAAA,GAAY5G,EAAM,SAEtB/B,OAAOC,SAAS4D,OAAO9B,EAAKC,WAAWpD,OAAQ,IAC/C,GAGCiC,EACLkB,EACA,OACA,CAAC2F,QAAAA,EAAS9I,MAAAA,EAAOuI,OAAQD,EAAgBlG,IACzCA,EAEH,C,2BCrBKtB,IAAS8E,EAAAA,EAAAA,GAAe,UACxB6E,IAAQ7E,EAAAA,EAAAA,GAAe,SAMtB,SAAS8E,GAAMzI,EAAGkB,GACvB,IAUIX,EAVAL,EAAQH,EAAIC,EAAGkB,GAGbC,EAAaD,EAAKC,WAClBuH,EAASF,GAAMtH,IAAS8B,OAAO7B,EAAWuH,QAAU,IACtDxB,EAAMlE,OAAO7B,EAAW+F,KAAO,IAC/B7G,GAAS,EAETsI,GAAwB,EAO5B,IAHAC,EAAAA,EAAAA,IAAM,CAACpI,KAAM,OAAQL,SAAUD,GAAQ,QAsCvC,WAEE,OADAyI,GAAwB,EACjBE,GAAAA,EACR,IAtCGF,GAAyB9G,EAAW3B,GACtC,OAAOA,EAIT,MAAQgH,KAAS7G,EAAQa,EAAKf,SAASG,QACrCC,EAAQW,EAAKf,SAASE,GAClBxB,GAAO0B,KAET2G,EAAMlE,OAAOzC,EAAMY,WAAW+F,KAAO,KAiBzC,OAZIwB,IACFxI,EAAQ,CACN,CACEM,KAAM,QACN2G,MAAO,KACP7O,IAAKwK,EAAQ9C,EAAG0I,GAChBtB,KAAK7H,EAAAA,GAAAA,GAAS,CAACY,SAAUD,OAMxB,CACLM,KAAM,OAEN2G,MAAOjG,EAAKC,WAAWgG,OAAS,KAChC7O,IAAKwK,EAAQ9C,EAAGkH,GAEhB/G,SAAUD,EAOb,CCjEM,SAAS0D,GAAE5D,EAAGkB,GACnB,IAAMhB,EAAQH,EAAIC,EAAGkB,GAErB,GAAIhB,EAAMI,OAAS,EACjB,OAAON,EAAEkB,EAAM,YAAahB,EAE/B,CCNM,SAAS4I,GAAO9I,EAAGkB,GACxB,OAAOlB,EAAEkB,EAAM,SAAUnB,EAAIC,EAAGkB,GACjC,CCDM,SAAS6H,GAAU/I,EAAGkB,GAC3B,IAAMQ,EAAO1B,EAAEiB,SAEfjB,EAAEiB,UAAW,EAEb,IAAMP,EAASV,EAAEkB,EAAM,YAAanB,EAAIC,EAAGkB,IAE3C,GAAIA,EAAKC,aAAeD,EAAKC,WAAW6H,SAAW9H,EAAKC,WAAW8H,SAAU,CAC3E,IAAMzM,EAAOkE,EAAOlE,OAASkE,EAAOlE,KAAO,CAAC,GACxC0E,EAAKC,WAAW6H,UAASxM,EAAKwM,QAAU9H,EAAKC,WAAW6H,SACxD9H,EAAKC,WAAW8H,UAASzM,EAAKyM,QAAU/H,EAAKC,WAAW8H,QAC7D,CAID,OAFAjJ,EAAEiB,SAAWS,EAENhB,CACR,CCTD,IAAMwI,IAAQvF,EAAAA,EAAAA,GAAe,SACvBwF,IAAKxF,EAAAA,EAAAA,GAAe,MACpBE,IAAOF,EAAAA,EAAAA,GAAe,CAAC,KAAM,OAqLnC,SAASyF,GAAQjJ,GASf,IAPA,IAGIe,EAEAc,EAmBO,EAxBL9B,EAAQ,GACVG,GAAS,IAMJA,EAAQF,EAASG,QAGxB,GAAkB,eAFlBY,EAAOf,EAASE,IAEPG,KAAsB,CAClB,MAAX,GAAIwB,GACF,EAAAd,EAAKf,UAASgF,QAAd,gBAAyBnD,IACzBA,OAAQnE,EAGVqC,EAAMY,KAAKI,EACZ,MACMc,IAAOA,EAAQ,IAEpBA,EAAMlB,KAAKI,GAIXc,KACFd,EAAOhB,EAAMA,EAAMI,OAAS,MAG1BY,EAAO,CAACV,KAAM,YAAaL,SAAU,IACrCD,EAAMY,KAAKI,KAGb,EAAAA,EAAKf,UAASW,KAAd,gBAAsBkB,KAGxB,OAAO9B,CACR,CChNM,IAAMoB,GAAW,CACtB+H,KCrBK,SAAcrJ,EAAGkB,GACtB,IAAIf,EAAWJ,EAAIC,EAAGkB,GAMtB,OAJIlB,EAAEsJ,UAAYzH,EAAW1B,MAC3BA,EAAWuB,EAAKvB,IAGXH,EAAEkB,EAAM,OAAQf,EACxB,EDcCoJ,KEvBK,SAAcvJ,EAAGkB,GACtB,OAAOlB,EAAEkB,EAAM,OAAQD,EAASjB,EAAGkB,EAAK5D,OACzC,EFsBCkM,QGzBK,SAAiBxJ,EAAGkB,GACzB,OAAOlB,EAAEkB,EAAM,OAAQ,UAASD,EAASjB,EAAGkB,EAAK5D,OAAS,SAC3D,EHwBCmM,QAASC,GAETC,OAAQD,GACRE,KAAMF,GACNG,SAAUH,GACVI,QAASJ,GACTK,QAASL,GACTM,IAAKN,GACLO,SAAUP,GACVQ,QAASR,GACT3B,QAAS2B,GACTzB,SAAUyB,GACVS,OAAQT,GACRU,QAASV,GACTW,MAAOX,GACPY,MAAOZ,GACPa,SAAUb,GACVc,QAASd,GACTe,OAAQf,GACRgB,KAAMhB,GACNiB,KAAMjB,GACNkB,KAAMlB,GACNmB,SAAUnB,GACVvD,KAAMuD,GACNoB,OAAQpB,GACRqB,QAASrB,GACTsB,SAAUtB,GACVuB,SAAUvB,GACVpC,OAAQoC,GACRwB,MAAOxB,GACPyB,OAAQzB,GACR0B,OAAQ1B,GACR7K,OAAQ6K,GACR2B,OAAQ3B,GACR4B,MAAO5B,GACP6B,IAAK7B,GACL8B,SAAU9B,GACVvC,MAAOuC,GACP+B,MAAO/B,GAEPgC,KAAM3L,EACN4L,QAAS5L,EACT6L,IAAK7L,EACL8L,IAAK9L,EACL+L,IAAK/L,EACLgM,MAAOhM,EACPiM,OAAQjM,EACRkM,OAAQlM,EACRmM,KAAMnM,EACNvD,KAAMuD,EACNoM,QAASpM,EACTqM,IAAKrM,EACLsM,KAAMtM,EACNuM,IAAKvM,EACLiI,MAAOjI,EACPwM,IAAKxM,EACLyM,QAASzM,EACT0M,MAAO1M,EACP2M,KAAM3M,EACN4M,SAAU5M,EACV6M,OAAQ7M,EACR8M,OAAQ9M,EACR+M,SAAU/M,EACVgN,GAAIhN,EACJiN,IAAKjN,EACLkN,GAAIlN,EACJmN,GAAInN,EACJoN,IAAKpN,EACLqN,KAAMrN,EACNsN,KAAMtN,EACNuN,MAAOvN,EACPwN,KAAMxN,EACNyN,IAAKzN,EACL0N,IAAK1N,EACL2N,MAAO3N,EACP4N,MAAO5N,EACPmJ,MAAOnJ,EACP6N,KAAM7N,EAEN8N,QAAShL,EACTiL,QAASjL,EACTkL,MAAOlL,EACPmL,KAAMnL,EACNoL,OAAQpL,EACR4D,IAAK5D,EACLqL,SAAUrL,EACVsL,WAAYtL,EACZuL,OAAQvL,EACRwL,KAAMxL,EACNyL,OAAQzL,EACR0L,OAAQ1L,EACR2L,OAAQ3L,EACR4L,KAAM5L,EACN6L,OAAQ7L,EACR8L,KAAM9L,EACN+L,SAAU/L,EACVgM,IAAKhM,EACLiM,QAASjM,EACTkM,QAASlM,EAETmM,EI3HK,SAAWhP,EAAGkB,GAGnB,IAAM0E,EAAQ1E,EAAKC,WACnB,OAAOnB,EACLkB,EACA,OACA,CACEiG,MAAOvB,EAAMuB,OAAS,KACtB7O,IAAKwK,EAAQ9C,EAAGgD,OAAO4C,EAAMqJ,MAAQ,KAAO,OAE9ClP,EAAIC,EAAGkB,GAEV,EJ+GCgO,MAAOzG,GACP0G,EAAGrG,GACH5M,KKlIK,SAAc8D,EAAGkB,GACjBlB,EAAEoP,YACLpP,EAAE+C,cACAC,OAAQ9B,EAAKC,YAAcD,EAAKC,WAAW8N,MAAS,KAAO,KAC7DjP,EAAEoP,WAAY,EAEjB,EL6HCC,WMjIK,SAAoBrP,EAAGkB,GAC5B,OAAOlB,EAAEkB,EAAM,aAAc2B,EAAa7C,EAAGkB,GAC9C,ENgICwC,GOpIK,SAAY1D,EAAGkB,GACpB,OAAOlB,EAAEiB,SAAWjB,EAAEkB,EAAM,SAAWlB,EAAEkB,EAAM,OAAQ,IACxD,EPmIC9D,KAAMiK,GACNiI,IAAK/G,GACLgH,GdrHK,SAAYvP,EAAGkB,GAepB,IAdA,IASIX,EAEAG,EAXEP,EAAWe,EAAKf,SAClBE,GAAS,EAETmP,EAAQ,GAENC,EAAS,GAEXC,EAAQ,CAACC,OAAQ,GAAIC,YAAa,MAO7BvP,EAAQF,EAASG,QACxBC,EAAQJ,EAASE,GACjBmP,EAAQA,EAAMpN,OAAOqE,EAAIlG,GAASA,EAAMJ,SAAWI,GAMrD,IAHAF,GAAS,IAGAA,EAAQmP,EAAMlP,QACrBC,EAAQiP,EAAMnP,GAEVqG,EAAGnG,IACDoG,EAAG6I,EAAMnP,EAAQ,MACnBoP,EAAO3O,KAAK4O,GACZA,EAAQ,CAACC,OAAQ,GAAIC,YAAa,KAGpCF,EAAMC,OAAO7O,KAAKP,IAElBmP,EAAME,YAAY9O,KAAKP,GAI3BkP,EAAO3O,KAAK4O,GAGZrP,GAAS,EAIT,IAFA,IAAM0H,EAAU,KAEP1H,EAAQoP,EAAOnP,SACtBI,EAAS,GAAH,eACDkG,EAAO5G,EAAGyP,EAAOpP,GAAOsP,UADvB,OAED/I,EAAO5G,EAAGyP,EAAOpP,GAAOuP,gBAGlBtP,OAAS,GAClByH,EAAQjH,KAAK,CACXN,KAAM,WACN8F,OAAQ5F,EAAOJ,OAAS,EACxBkG,QAAS,KACTrG,SAAUO,IAMhB,GAAIqH,EAAQzH,OAAS,EACnB,OAAON,EACLkB,EACA,OACA,CAAC2F,SAAS,EAAO9I,MAAO,KAAMuI,OAAQD,EAAgB0B,IACtDA,EAGL,EcgDCrB,GAAIyB,GACJxB,GAAIwB,GACJ/B,IAAAA,EACAU,GAAAA,EACA+I,GAAI9I,GACJ+I,GAAI/I,GACJgJ,GAAIhJ,GACJiJ,GAAIjJ,GACJkJ,GAAIlJ,GACJmJ,GAAInJ,GACJoJ,GQlJK,SAAYnQ,EAAGkB,GACpB,OAAOlB,EAAEkB,EAAM,gBAChB,ERiJCkP,EAAGtJ,EACHuJ,OShJK,SAAgBrQ,EAAGkB,GAGxB,IAAM0E,EAAQ1E,EAAKC,WACb+F,EAAMlE,OAAO4C,EAAMsB,KAAO,IAC1BC,EAAQnE,OAAO4C,EAAMuB,OAAS,IAMpC,GAAID,GAAOC,EACT,MAAO,CACL3G,KAAM,OACN2G,MAAO,KACP7O,IAAKwK,EAAQ9C,EAAGkH,GAChB/G,SAAU,CAAC,CAACK,KAAM,OAAQlD,MAAO2D,EAASjB,EAAGmH,KAGlD,ET8HCF,IAAAA,GACAqJ,MAAOrJ,GACPiB,MR5IK,SAAelI,EAAGkB,GAGvB,IAUIqH,EAVE3C,EAAQ1E,EAAKC,WACf7D,EAAQ0F,OAAO4C,EAAMtI,OAASsI,EAAM2K,aAAe,IAEjDlM,EAAU,GAEVmM,EAAQ,GAEVpQ,EAAS,GACTC,GAAS,EAIb,IAAIuF,EAAM6K,UAA2B,WAAf7K,EAAMpF,MAAoC,SAAfoF,EAAMpF,KAAvD,CAIA,GAAmB,aAAfoF,EAAMpF,MAAsC,UAAfoF,EAAMpF,KACrC,OAAOR,EACLkB,EACA,OACAD,EAASjB,EAAGA,EAAE4F,EAAMY,QAAU,UAAY,eAI9C,GAAmB,UAAfZ,EAAMpF,KACR,OAAOoF,EAAMwB,KAAO9J,EAChB0C,EAAEkB,EAAM,QAAS,CACf5I,IAAKwK,EAAQ9C,EAAGgD,OAAO4C,EAAMsB,KAAO,KAAO,MAC3CC,MAAOlG,EAASjB,EAAGgD,OAAO4C,EAAMuB,OAAS,MAAQ,KACjDC,IAAKnG,EAASjB,EAAGgD,OAAO4C,EAAMwB,KAAO9J,MAEvC,GAqBN,GAlBIA,EACF8C,EAAS,CAAC,CAAC9C,EAAO,OAGH,aAAfsI,EAAMpF,MACS,SAAfoF,EAAMpF,MACS,WAAfoF,EAAMpF,MACS,UAAfoF,EAAMpF,MACS,WAAfoF,EAAMpF,MACNoF,EAAM2C,OAENA,EAAOvF,OAAO4C,EAAM2C,MAAM7K,cAEtBqD,EAAIM,KAAKrB,EAAE0Q,SAAUnI,IAASN,GAASjI,EAAE0Q,SAASnI,MACpDnI,EAASmH,GAAoBvH,EAAGA,EAAE0Q,SAASnI,GAAO3C,KAIhC,IAAlBxF,EAAOE,OAAX,CAUA,GALmB,aAAfsF,EAAMpF,OAERJ,EAAO,GAAK,CAAC,SAAI0E,OAAO1E,EAAO,GAAG,GAAGE,QAAS,OAG7B,QAAfsF,EAAMpF,MAAiC,UAAfoF,EAAMpF,KAAkB,CAClD,OAASH,EAAQD,EAAOE,QACtBhD,EAAQwF,EAAQ9C,EAAGI,EAAOC,GAAO,IAEjCgE,EAAQvD,KACNd,EACEkB,EACA,OACA,CACEiG,MAAO,KACP7O,IAAK2I,EAASjB,EAAkB,UAAf4F,EAAMpF,KAAmB,UAAYlD,EAAQA,IAEhE,CAAC,CAACkD,KAAM,OAAQlD,MAAO2D,EAASjB,EAAGI,EAAOC,GAAO,IAAM/C,OAIvD+C,IAAUD,EAAOE,OAAS,GAC5B+D,EAAQvD,KAAK,CAACN,KAAM,OAAQlD,MAAO,OAIvC,OAAO+G,CACR,CAED,OAAShE,EAAQD,EAAOE,QACtBkQ,EAAM1P,KACJV,EAAOC,GAAO,GACVD,EAAOC,GAAO,GAAK,KAAOD,EAAOC,GAAO,GAAK,IAC7CD,EAAOC,GAAO,IAItB,OAAOL,EAAEkB,EAAM,OAAQD,EAASjB,EAAGwQ,EAAMzL,KAAK,OAxC7C,CAxCA,CAiFF,EQ2CC4L,IAAKtJ,GACLc,GAAAA,GACAyI,QAASxT,EACTyT,KAAM/J,EACNwB,GAAIC,GACJ3E,EAAAA,GACAkN,UAAW1T,EACX0I,IAAK1I,EACL2T,EU7JK,SAAW/Q,EAAGkB,GACnB,IAAM8P,EAAWhR,EAAEiR,OAAOjR,EAAEkR,SAAWlR,EAAEiR,OAAO3Q,QAEhDN,EAAEkR,WACF,IAAMC,EAAWpR,EAAIC,EAAGkB,GAUxB,OATAlB,EAAEkR,WAEFC,EAAShM,QAAQ,CAAC3E,KAAM,OAAQlD,MAAO0T,EAASvT,OAAO,KAEvD0T,EAASrQ,KAAK,CACZN,KAAM,OACNlD,MAAO0T,EAAS1Q,OAAS,EAAI0Q,EAASvT,OAAO,GAAKuT,IAG7CG,CACR,EV+ICC,EAAGhL,EACHiL,KAAMhK,GACNiK,OWhKK,SAAgBtR,EAAGkB,GAQxB,IAPA,IAKI5D,EALE8C,EAASmH,GAAoBvH,EAAGkB,GAClCb,GAAS,EAEPgE,EAAU,KAIPhE,EAAQD,EAAOE,QACtBhD,EAAQ8C,EAAOC,GACfgE,EAAQvD,KAAKxD,EAAM,GAAKA,EAAM,GAAK,KAAOA,EAAM,GAAK,IAAMA,EAAM,IAGnE,GAAI+G,EAAQ/D,OAAS,EACnB,OAAON,EAAEkB,EAAM,OAAQD,EAASjB,EAAGqE,EAAQU,KAAK,OAEnD,EXiJCwM,OAAQnL,EACR0C,OAAAA,GACA0I,QAAS5N,GACT6N,MDrJK,SAAezR,EAAGkB,GACvB,GAAIlB,EAAE0R,QACJ,OAAO1R,EAAEkB,EAAM,OAAQD,EAASjB,EAAGoE,EAAOlD,KAG5ClB,EAAE0R,SAAU,EAOZ,IALA,MA8EF,SAAiBxQ,GACf,IAAIyQ,GAAW,EACXC,EAAW,EACXC,EAAY,EAEVC,EAAQ,CAAC,MA2Bf,OAzBAlJ,EAAAA,EAAAA,IAAM1H,EAAM,WAAW,SAACX,GACtB,GAAsB,UAAlBA,EAAME,SAAuBS,IAASX,EACxC,OAAOwR,GAAAA,GAILlO,GAAKtD,IAAUA,EAAMY,YAClB2Q,EAAMD,KACTC,EAAMD,GAAa7O,OAAOzC,EAAMY,WAAW2Q,OAAS,KAAO,MAIzDH,GAAYC,EAAW,GAAuB,OAAlBrR,EAAME,UACpCkR,GAAW,GAGbE,KACS3I,GAAM3I,GACfoR,GAAW,EACFxI,GAAG5I,KACZqR,IACAC,EAAY,EAEf,IAEM,CAACC,MAAAA,EAAOH,SAAAA,EAChB,CA/G2BK,CAAQ9Q,GAA3ByQ,EAAP,EAAOA,SAAUG,EAAjB,EAAiBA,MACXG,EAuHR,SAAgB9R,EAAUwR,GACxB,IAII3P,EAwBO,EA5BP3B,GAAS,EAEPH,EAAQ,GAKVyR,GACFzR,EAAMY,KAAK,CAACN,KAAM,WAAYL,SAAU,KAG1C,OAASE,EAAQF,EAASG,QAAQ,CAChC,IAAMY,EAAOf,EAASE,GAEtB,GAAkB,aAAda,EAAKV,KAAqB,CACjB,MAAX,GAAIwB,GACF,EAAAd,EAAKf,UAASgF,QAAd,gBAAyBnD,IACzBA,OAAQnE,EAGVqC,EAAMY,KAAKI,EACZ,MACMc,IAAOA,EAAQ,IAEpBA,EAAMlB,KAAKI,EAEd,CAEGc,IACF,EAAA9B,EAAMA,EAAMI,OAAS,GAAGH,UAASW,KAAjC,gBAAyCkB,IAG3C3B,GAAS,EAET,OAASA,EAAQH,EAAMI,QACrBJ,EAAMG,GAAOF,SAAWiJ,GAAQlJ,EAAMG,GAAOF,UAG/C,OAAOD,CACR,CA/JcgS,CAAOnS,EAAIC,EAAGkB,GAAOyQ,GAC9BQ,EAAU,EACVP,GAAY,IAEPA,EAAWK,EAAK3R,QAAQ,CAI/B,IAHA,IAAM8R,EAAQH,EAAKL,GAAUzR,SACzB0R,GAAa,IAERA,EAAYO,EAAM9R,QAAQ,CACjC,IAAMuD,EAAOuO,EAAMP,GAEnB,GAAIhO,EAAKrH,KAAM,CACb,IAAMyM,EAAU9J,OAAOC,SAAS4D,OAAOa,EAAKrH,KAAKyM,SAAU,KAAO,EAC5DD,EAAU7J,OAAOC,SAAS4D,OAAOa,EAAKrH,KAAKwM,SAAU,KAAO,EAElE,GAAIC,EAAU,GAAKD,EAAU,EAG3B,IAFA,IAAIqJ,EAAgBT,EAAW,IAEtBS,EAAgBT,EAAW5I,GAGlC,IAFA,IAAIsJ,EAAWT,EAAY,IAElBS,EAAWT,EAAY5I,GAAS,OACvC,IAAKgJ,EAAKI,GAGR,MAIF,IAAME,EAAW,GAEbF,IAAkBT,GAAYU,IAAaT,GAC7CU,EAASzR,KAAK,CAACN,KAAM,YAAaL,SAAU,MAG9C,EAAA8R,EAAKI,GAAelS,UAASqS,OAA7B,SAAoCF,EAAU,GAA9C,OAAoDC,GACrD,CAKD,YAAa1O,EAAKrH,aAAaqH,EAAKrH,KAAKyM,QACzC,YAAapF,EAAKrH,aAAaqH,EAAKrH,KAAKwM,QACP,IAAlCtM,OAAO+V,KAAK5O,EAAKrH,MAAM8D,eAAqBuD,EAAKrH,IACtD,CACF,CAEG4V,EAAM9R,OAAS6R,IAASA,EAAUC,EAAM9R,OAC7C,CAKD,IAFAsR,GAAY,IAEHA,EAAWK,EAAK3R,QAGvB,IAFA,IAAM8R,EAAQH,EAAKL,GAAUzR,SACzB0R,EAAYO,EAAM9R,OAAS,IACtBuR,EAAYM,GACnBC,EAAMtR,KAAK,CAACN,KAAM,YAAaL,SAAU,KAK7C,IADA,IAAIuS,EAAaZ,EAAMxR,OAAS,IACvBoS,EAAaP,GACpBL,EAAMhR,KAAK,MAKb,OAFAd,EAAE0R,SAAU,EAEL1R,EAAEkB,EAAM,QAAS,CAAC4Q,MAAAA,GAAQG,EAClC,ECyECU,GAAI5J,GACJ6J,SYtKK,SAAkB5S,EAAGkB,GAC1B,OAAOlB,EAAEkB,EAAM,OAAQD,EAASjB,EAAGoE,EAAOlD,IAC3C,EZqKC2R,GAAI9J,GACJI,GazKK,SAAkBnJ,EAAGkB,GAC1B,OAAOlB,EAAEkB,EAAM,WAAYnB,EAAIC,EAAGkB,GACnC,EbwKC4R,GAAIzL,GACJ0L,EAAGjM,EACHkM,GAAIzK,GACJ0K,IAAK5L,GACLmB,MAAOC,GACPyK,IcjLK,SAAalT,EAAGkB,GACrB,OAAOlB,EAAEkB,EAAM,OAAQ,SACxB,EdgLCiS,IAAK/V,GAGP,SAASsM,KAAW,CexKpB,IAAMnF,IAAQ9C,EAAAA,EAAAA,GAAQ,CAAC,UAAW,YAAa,SAUxC,SAAS2R,GAAQC,GAAoB,IAItCC,EAJwBjX,EAAc,uDAAJ,CAAC,EAEjCkX,EAAO,CAAC,EAORvT,EAAItD,OAAOC,QAWb,SAACuE,EAAMV,EAAMoF,EAAOzF,GAElB,IAAIgB,EAEiB,kBAAVyE,GAAsBhF,MAAMC,QAAQ+E,IAC7CzF,EAAWyF,EACXzE,EAAa,CAAC,GAEdA,EAAayE,EAKf,IAAMlF,GAAS,QAACF,KAAAA,GAASW,GAczB,MAZwB,kBAAbhB,EAETO,EAAOpD,MAAQ6C,EACNA,IAETO,EAAOP,SAAWA,GAGhBe,EAAKsS,WACP9S,EAAO8S,SAAWtS,EAAKsS,UAGlB9S,CACR,GAEH,CACEgQ,SAAU6C,EACVnE,WAAW,EACXsC,SAAS,EACTzQ,UAAU,EAEV8B,cAAe,KACfmO,SAAU,EACV5P,SAAUjF,EAAQiF,UAAR,kBACFA,IAAajF,EAAQiF,UACzBA,GACJgI,SAAUjN,EAAQiN,SAClB9C,QAASnK,EAAQmK,SAAW,MAC5BiN,UAAWpX,EAAQoX,WAAa,MAChCxC,OAAQ5U,EAAQ4U,QAAU,CAAC,QAI/BrI,EAAAA,EAAAA,IAAMyK,EAAM,WAAW,SAACnS,GACtB,IAAMwS,EACJxS,EAAKC,YACL,OAAQD,EAAKC,YACb6B,OAAO9B,EAAKC,WAAWuS,IAAIhW,cAEzBgW,IAAO3S,EAAIM,KAAKkS,EAAMG,KACxBH,EAAKG,GAAMxS,EAEd,KAGDyS,EAAAA,EAAAA,GAAuB,CAACC,UAA+B,IAArBvX,EAAQuX,UAA1CD,CAA8DN,GAE9D,IAAM3S,EAASC,EAAIX,EAAGqT,OAAMxV,GAY5B,OAPEyV,EAHG5S,EAEME,MAAMC,QAAQH,GACf,CAACF,KAAM,OAAQL,SAAUO,GAEzBA,EAJA,CAACF,KAAM,OAAQL,SAAU,KAOnCyI,EAAAA,EAAAA,IAAM0K,EAAO,OAAQO,GAEdP,EAWP,SAASO,EAAO3S,EAAMb,EAAOJ,GAE3B,GAAc,OAAVI,GAAmBJ,EAAvB,CAIA,IAAM6T,EAAW7T,EAAOE,SAASE,EAAQ,GAEzC,OAAIyT,GAAYA,EAAStT,OAASU,EAAKV,MACrCsT,EAASxW,OAAS4D,EAAK5D,MACvB2C,EAAOE,SAASqS,OAAOnS,EAAO,GAE1ByT,EAASN,UAAYtS,EAAKsS,WAC5BM,EAASN,SAASlV,IAAM4C,EAAKsS,SAASlV,KAIjC+B,EAAQ,IAGjBa,EAAK5D,MAAQ4D,EAAK5D,MAAMC,QAAQ,yBAA0B,MAItD0C,GAAUsE,GAAMtE,KACbI,IACHa,EAAK5D,MAAQ4D,EAAK5D,MAAMC,QAAQ,UAAW,KAGzC8C,IAAUJ,EAAOE,SAASG,OAAS,IACrCY,EAAK5D,MAAQ4D,EAAK5D,MAAMC,QAAQ,UAAW,MAI1C2D,EAAK5D,WAAV,GACE2C,EAAOE,SAASqS,OAAOnS,EAAO,GACvBA,GAhCR,CAkCF,CACF,CC1JD,IA8BA,GArBI,SAAU0T,EAAa1X,GAErB,IAAII,EAEAuX,EAaJ,MAX2B,oBAAhBD,GACTC,EAAYD,EACZtX,EAAWJ,GAAW,CAAC,GAEvBI,EAAWsX,GAAe,CAAC,OAGHlW,IAAtBpB,EAAS6M,UAAgD,OAAtB7M,EAAS6M,WAC9C7M,EAAWC,OAAOC,OAAO,CAAC,EAAGF,EAAU,CAAC6M,UAAU,KAG7C0K,EAYb,SAAgBD,EAAa1X,GAC3B,OAAO,SAAC6E,EAAMpE,EAAMmX,GAClBF,EAAYG,IAAId,GAAQlS,EAAM7E,GAAUS,GAAM,SAACK,GAC7C8W,EAAK9W,EACN,GACF,CACF,CAlBwBgX,CAAOH,EAAWvX,GA0B3C,WAA8B,IAAdJ,EAAc,uDAAJ,CAAC,EACzB,OAAO,SAAC6E,GAEN,OADyCkS,GAAQlS,EAAM7E,EAExD,CACF,CA/BsD+X,CAAO3X,EACzD,C,gFCvCE,SAAS4X,EAAUnY,EAAMoY,GAC9B,IAEIC,EAFAlU,GAAS,EAKb,GAAIiU,EAAUE,WACZ,OAASnU,EAAQiU,EAAUE,WAAWlU,QACpC+T,EAAUnY,EAAMoY,EAAUE,WAAWnU,IAIzC,IAAKkU,KAAOD,EACE,eAARC,IAEe,WAARA,GAA4B,SAARA,EAG7BrY,EAAKqY,GAAL,kBAAiBrY,EAAKqY,IAAQ,KAA9B,OAAuCD,EAAUC,IAAQ,KACxC,aAARA,EACTrY,EAAKqY,GAAO7X,OAAOC,OAAOT,EAAKqY,GAAMD,EAAUC,IAAQ,CAAC,GAGxDrY,EAAKG,QAAQkY,GAAOD,EAAUC,IAIlC,OAAOrY,CACR,C,mCCVD,SAASqQ,EAAIvO,EAAMiB,EAAGwV,GACpB,MAAO,KAAOA,EAAQ,GAAK,KAAOzW,CACnC,C,eCnBM,SAAS0W,EAAUzV,EAAG0V,EAAIC,EAASC,GAGxC,IAFA,IAAIxU,GAAS,IAEJA,EAAQuU,EAAQE,OAAOxU,QAG9B,GACsC,OAApCsU,EAAQE,OAAOzU,GAAO0U,YACtBC,EAAAA,EAAAA,GAAeJ,EAAQK,MAAOL,EAAQE,OAAOzU,IAE7C,MAAO,QAAQ8C,KAAK0R,EAAKK,QAAU,GAAK,IAI5C,MAAO,MACR,C,eChBM,SAASC,EAAqBjU,EAAM0T,GACzC,OAAO5Q,SACJ4Q,EAAQvY,QAAQ+Y,QACflU,EAAK5D,QAEJ4D,EAAK+E,MAEN,WAAW9C,KAAKjC,EAAK5D,SAEpB,0CAA0C6F,KAAKjC,EAAK5D,OAE1D,C,eCqDD,SAASiP,EAAIvO,EAAMiB,EAAGwV,GACpB,OAAQA,EAAQ,GAAK,QAAUzW,CAChC,C,eCnEM,SAASqX,EAAWT,GACzB,IAAMU,EAASV,EAAQvY,QAAQkZ,OAAS,IAExC,GAAe,MAAXD,GAA6B,MAAXA,EACpB,MAAM,IAAIjS,MACR,gCACEiS,EACA,gDAIN,OAAOA,CACR,C,eCFM,SAASE,EAAStU,EAAMjC,EAAG2V,EAASa,GACzC,IAAMH,ECXD,SAAuBV,GAC5B,IAAMU,EAASV,EAAQvY,QAAQmZ,UAAY,IAE3C,GAAe,MAAXF,GAA6B,MAAXA,EACpB,MAAM,IAAIjS,MACR,mCACEiS,EACA,kDAIN,OAAOA,CACR,CDDgBI,CAAcd,GACvBe,EAAOf,EAAQgB,MAAM,YACrBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAKR,GAUzB,OATAhY,GAASuY,EAAQC,MACfC,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QACfM,OAAQ5X,EACR0Y,MAAOV,GACJO,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAKR,GACtBK,IACOrY,CACR,CAzBDkY,EAASU,KA+BT,SAAsBjX,EAAG0V,EAAIC,GAC3B,OAAOA,EAAQvY,QAAQmZ,UAAY,GACpC,E,mCE7BM,SAASW,EAAsBjV,EAAM0T,GAC1C,IAAIwB,GAAmB,EAcvB,OAVAxN,EAAAA,EAAAA,IAAM1H,GAAM,SAACA,GACX,GACG,UAAWA,GAAQ,WAAWiC,KAAKjC,EAAK5D,QAC3B,UAAd4D,EAAKV,KAGL,OADA4V,GAAmB,EACZvN,EAAAA,EAEV,IAEM7E,UACH9C,EAAK8F,OAAS9F,EAAK8F,MAAQ,KAC3BzH,EAAAA,EAAAA,GAAS2B,KACR0T,EAAQvY,QAAQga,QAAUD,GAEhC,CCtBM,SAAS3H,EAAKvN,GACnB,OAAOA,EAAK5D,OAAS,EACtB,CCEM,SAASgT,EAAMpP,EAAMjC,EAAG2V,EAASa,GACtC,IAAMF,EAAQF,EAAWT,GACnB3P,EAAmB,MAAVsQ,EAAgB,QAAU,aACnCI,EAAOf,EAAQgB,MAAM,SACvBU,EAAU1B,EAAQgB,MAAM,SACtBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAK,MAmDzB,OAlDAxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKkG,KAAf,QAAqB8N,OAAQ5X,EAAO0Y,MAAO,KAAQH,EAAQI,aAEjE3Y,GAASuY,EAAQC,KAAK,MAEtBQ,KAIIpV,EAAK5I,KAAO4I,EAAKiG,OAEnB,eAAehE,KAAKjC,EAAK5I,MAEzBge,EAAU1B,EAAQgB,MAAM,sBACxBtY,GAASuY,EAAQC,KAAK,KACtBxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QAAqB4c,OAAQ5X,EAAO0Y,MAAO,KAAQH,EAAQI,aAEjE3Y,GAASuY,EAAQC,KAAK,OAGtBQ,EAAU1B,EAAQgB,MAAM,kBACxBtY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QACF4c,OAAQ5X,EACR0Y,MAAO9U,EAAKiG,MAAQ,IAAM,KACvB0O,EAAQI,cAKjBK,IAEIpV,EAAKiG,QACPmP,EAAU1B,EAAQgB,MAAM,QAAU3Q,GAClC3H,GAASuY,EAAQC,KAAK,IAAMP,GAC5BjY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKiG,OAAf,QACF+N,OAAQ5X,EACR0Y,MAAOT,GACJM,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAKP,GACtBe,KAGFhZ,GAASuY,EAAQC,KAAK,KACtBH,IAEOrY,CACR,CC1DM,SAASiZ,EAAerV,EAAMjC,EAAG2V,EAASa,GAC/C,IAAMjV,EAAOU,EAAKsV,cACZb,EAAOf,EAAQgB,MAAM,kBACvBU,EAAU1B,EAAQgB,MAAM,SACtBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAK,MACnB1O,GAAMyN,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKkG,KAAf,QACd8N,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,YAEb3Y,GAASuY,EAAQC,KAAK1O,EAAM,MAE5BkP,IAEA,IAAMrB,EAAQL,EAAQK,MACtBL,EAAQK,MAAQ,GAChBqB,EAAU1B,EAAQgB,MAAM,aAKxB,IAAMa,GAAY5B,EAAAA,EAAAA,GAAKD,GAAS8B,EAAAA,EAAAA,GAAYxV,IAAtB,QACpBgU,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,YAeb,OAbAK,IACA1B,EAAQK,MAAQA,EAChBU,IAEa,SAATnV,GAAoB4G,GAAOA,IAAQqP,EAEnB,aAATjW,EAETlD,EAAQA,EAAMqI,MAAM,GAAI,GAExBrI,GAASuY,EAAQC,KAAK,KALtBxY,GAASuY,EAAQC,KAAKW,EAAY,KAQ7BnZ,CACR,CFnDDmR,EAAKyH,KAaL,WACE,MAAO,GACR,ECXD5F,EAAM4F,KAqEN,WACE,MAAO,GACR,ECvEDK,EAAeL,KAoDf,WACE,MAAO,GACR,E,eCnDM,SAASS,EAAqBzV,EAAM0T,GACzC,IAAMgC,GAAMrX,EAAAA,EAAAA,GAAS2B,GAErB,OAAO8C,SACJ4Q,EAAQvY,QAAQwa,cAEf3V,EAAK5I,MAEJ4I,EAAKiG,OAENjG,EAAKf,UACoB,IAAzBe,EAAKf,SAASG,QACY,SAA1BY,EAAKf,SAAS,GAAGK,OAEhBoW,IAAQ1V,EAAK5I,KAAO,UAAYse,IAAQ1V,EAAK5I,MAE9C,oBAAoB6K,KAAKjC,EAAK5I,OAG7B,iBAAiB6K,KAAKjC,EAAK5I,KAEjC,CCfM,SAASoS,EAAKxJ,EAAMjC,EAAG2V,EAASa,GACrC,IAIIE,EAEAW,EANEf,EAAQF,EAAWT,GACnB3P,EAAmB,MAAVsQ,EAAgB,QAAU,aACnCM,GAAUpK,EAAAA,EAAAA,GAAMgK,GAMtB,GAAIkB,EAAqBzV,EAAM0T,GAAU,CAEvC,IAAMK,EAAQL,EAAQK,MACtBL,EAAQK,MAAQ,GAChBU,EAAOf,EAAQgB,MAAM,YACrB,IAAItY,EAAQuY,EAAQC,KAAK,KAWzB,OAVAxY,GAASuY,EAAQC,MACfC,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QACfM,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAK,KACtBH,IACAf,EAAQK,MAAQA,EACT3X,CACR,CAEDqY,EAAOf,EAAQgB,MAAM,QACrBU,EAAU1B,EAAQgB,MAAM,SACxB,IAAItY,EAAQuY,EAAQC,KAAK,KAsDzB,OArDAxY,GAASuY,EAAQC,MACfC,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QACfM,OAAQ5X,EACR0Y,MAAO,MACJH,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAK,MACtBQ,KAIIpV,EAAK5I,KAAO4I,EAAKiG,OAEnB,eAAehE,KAAKjC,EAAK5I,MAEzBge,EAAU1B,EAAQgB,MAAM,sBACxBtY,GAASuY,EAAQC,KAAK,KACtBxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QAAqB4c,OAAQ5X,EAAO0Y,MAAO,KAAQH,EAAQI,aAEjE3Y,GAASuY,EAAQC,KAAK,OAGtBQ,EAAU1B,EAAQgB,MAAM,kBACxBtY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QACF4c,OAAQ5X,EACR0Y,MAAO9U,EAAKiG,MAAQ,IAAM,KACvB0O,EAAQI,cAKjBK,IAEIpV,EAAKiG,QACPmP,EAAU1B,EAAQgB,MAAM,QAAU3Q,GAClC3H,GAASuY,EAAQC,KAAK,IAAMP,GAC5BjY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKiG,OAAf,QACF+N,OAAQ5X,EACR0Y,MAAOT,GACJM,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAKP,GACtBe,KAGFhZ,GAASuY,EAAQC,KAAK,KAEtBH,IACOrY,CACR,CCvFM,SAASwZ,EAAc5V,EAAMjC,EAAG2V,EAASa,GAC9C,IAAMjV,EAAOU,EAAKsV,cACZb,EAAOf,EAAQgB,MAAM,iBACvBU,EAAU1B,EAAQgB,MAAM,SACtBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAK,KACnBvM,GAAOwM,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QAC5BM,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,YAEb3Y,GAASuY,EAAQC,KAAKvM,EAAO,MAE7B+M,IAEA,IAAMrB,EAAQL,EAAQK,MACtBL,EAAQK,MAAQ,GAChBqB,EAAU1B,EAAQgB,MAAM,aAKxB,IAAMa,GAAY5B,EAAAA,EAAAA,GAAKD,GAAS8B,EAAAA,EAAAA,GAAYxV,IAAtB,QACpBgU,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,YAeb,OAbAK,IACA1B,EAAQK,MAAQA,EAChBU,IAEa,SAATnV,GAAoB+I,GAAQA,IAASkN,EAErB,aAATjW,EAETlD,EAAQA,EAAMqI,MAAM,GAAI,GAExBrI,GAASuY,EAAQC,KAAK,KALtBxY,GAASuY,EAAQC,KAAKW,EAAY,KAQ7BnZ,CACR,CD7CDoN,EAAKwL,KAiGL,SAAkBhV,EAAMjC,EAAG2V,GACzB,OAAO+B,EAAqBzV,EAAM0T,GAAW,IAAM,GACpD,ECrGDkC,EAAcZ,KAoDd,WACE,MAAO,GACR,E,eCvDM,SAASa,EAAmBnC,GACjC,IAAMU,EAASV,EAAQvY,QAAQ2a,eAAiB,IAEhD,GAAe,MAAX1B,GAA6B,MAAXA,EACpB,MAAM,IAAIjS,MACR,gCACEiS,EACA,sDAIN,OAAOA,CACR,CCZM,SAAS2B,EAAUrC,GACxB,IAAMU,EAASV,EAAQvY,QAAQ6a,MAAQ,IAEvC,GAAe,MAAX5B,GAA6B,MAAXA,GAA6B,MAAXA,EACtC,MAAM,IAAIjS,MACR,gCACEiS,EACA,mDAIN,OAAOA,CACR,C,eCFM,SAASxM,EAAO5H,EAAMjC,EAAG2V,EAASa,GACvC,IAAMH,ECXD,SAAqBV,GAC1B,IAAMU,EAASV,EAAQvY,QAAQyM,QAAU,IAEzC,GAAe,MAAXwM,GAA6B,MAAXA,EACpB,MAAM,IAAIjS,MACR,iCACEiS,EACA,gDAIN,OAAOA,CACR,CDDgB6B,CAAYvC,GACrBe,EAAOf,EAAQgB,MAAM,UACrBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAKR,EAASA,GAUlC,OATAhY,GAASuY,EAAQC,MACfC,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QACfM,OAAQ5X,EACR0Y,MAAOV,GACJO,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAKR,EAASA,GAC/BK,IACOrY,CACR,CAzBDwL,EAAOoN,KA+BP,SAAoBjX,EAAG0V,EAAIC,GACzB,OAAOA,EAAQvY,QAAQyM,QAAU,GAClC,EEtBM,IAAMlC,EAAS,CACpByI,WlBPK,SAAoBnO,EAAMjC,EAAG2V,EAASa,GAC3C,IAAME,EAAOf,EAAQgB,MAAM,cACrBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GACtBI,EAAQC,KAAK,MACbD,EAAQuB,MAAM,GACd,IAAM9Z,GAAQ+Z,EAAAA,EAAAA,IACZC,EAAAA,EAAAA,GAAcpW,EAAM0T,EAASiB,EAAQI,WACrC1J,GAGF,OADAoJ,IACOrY,CACR,EkBHCia,MAAO7C,EACPtX,KfLK,SAAc8D,EAAMjC,EAAG2V,EAASa,GACrC,IAAMH,EgBVD,SAAoBV,GACzB,IAAMU,EAASV,EAAQvY,QAAQmb,OAAS,IAExC,GAAe,MAAXlC,GAA6B,MAAXA,EACpB,MAAM,IAAIjS,MACR,+BACEiS,EACA,kDAIN,OAAOA,CACR,ChBFgBmC,CAAW7C,GACpBgC,EAAM1V,EAAK5D,OAAS,GACpB2H,EAAoB,MAAXqQ,EAAiB,cAAgB,QAEhD,GAAIH,EAAqBjU,EAAM0T,GAAU,CACvC,IAAMe,EAAOf,EAAQgB,MAAM,gBACrBtY,GAAQ+Z,EAAAA,EAAAA,GAAYT,EAAKrK,GAE/B,OADAoJ,IACOrY,CACR,CAED,IAAMuY,GAAUpK,EAAAA,EAAAA,GAAMgK,GAChBiC,EAAWpC,EAAOxQ,OAAO4C,KAAKiQ,IiBrB/B,SAAuBra,EAAOyX,GACnC,IAAMlW,EAASmE,OAAO1F,GAClB+C,EAAQxB,EAAO0E,QAAQwR,GACvB/D,EAAW3Q,EACXiE,EAAQ,EACRqT,EAAM,EAEV,GAAyB,kBAAd5C,GAA+C,IAArBA,EAAUzU,OAC7C,MAAM,IAAI+C,MAAM,sBAGlB,MAAkB,IAAXhD,GACDA,IAAU2Q,IACN1M,EAAQqT,IACZA,EAAMrT,GAGRA,EAAQ,EAGV0M,EAAW3Q,EAAQ,EACnBA,EAAQxB,EAAO0E,QAAQwR,EAAW/D,GAGpC,OAAO2G,CACR,CjBJyCC,CAAchB,EAAKtB,GAAU,EAAG,IAClEK,EAAOf,EAAQgB,MAAM,cACvBtY,EAAQuY,EAAQC,KAAK4B,GAEzB,GAAIxW,EAAK+E,KAAM,CACb,IAAMqQ,EAAU1B,EAAQgB,MAAM,iBAAmB3Q,GACjD3H,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK+E,MAAf,QACFiP,OAAQ5X,EACR0Y,MAAO,IACP6B,OAAQ,CAAC,MACNhC,EAAQI,aAGfK,GACD,CAED,GAAIpV,EAAK+E,MAAQ/E,EAAKiF,KAAM,CAC1B,IAAMmQ,EAAU1B,EAAQgB,MAAM,iBAAmB3Q,GACjD3H,GAASuY,EAAQC,KAAK,KACtBxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKiF,MAAf,QACF+O,OAAQ5X,EACR0Y,MAAO,KACP6B,OAAQ,CAAC,MACNhC,EAAQI,aAGfK,GACD,CAUD,OARAhZ,GAASuY,EAAQC,KAAK,MAElBc,IACFtZ,GAASuY,EAAQC,KAAKc,EAAM,OAG9BtZ,GAASuY,EAAQC,KAAK4B,GACtB/B,IACOrY,CACR,Ee/CCwa,WGVK,SAAoB5W,EAAMjC,EAAG2V,EAASa,GAC3C,IAAMF,EAAQF,EAAWT,GACnB3P,EAAmB,MAAVsQ,EAAgB,QAAU,aACnCI,EAAOf,EAAQgB,MAAM,cACvBU,EAAU1B,EAAQgB,MAAM,SACtBC,GAAUpK,EAAAA,EAAAA,GAAMgK,GAClBnY,EAAQuY,EAAQC,KAAK,KAsDzB,OArDAxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,GAAS8B,EAAAA,EAAAA,GAAYxV,IAAtB,QACFgU,OAAQ5X,EACR0Y,MAAO,KACJH,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAK,OAEtBQ,KAIGpV,EAAK5I,KAEN,eAAe6K,KAAKjC,EAAK5I,MAEzBge,EAAU1B,EAAQgB,MAAM,sBACxBtY,GAASuY,EAAQC,KAAK,KACtBxY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QAAqB4c,OAAQ5X,EAAO0Y,MAAO,KAAQH,EAAQI,aAEjE3Y,GAASuY,EAAQC,KAAK,OAGtBQ,EAAU1B,EAAQgB,MAAM,kBACxBtY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5I,KAAf,QACF4c,OAAQ5X,EACR0Y,MAAO9U,EAAKiG,MAAQ,IAAM,MACvB0O,EAAQI,cAKjBK,IAEIpV,EAAKiG,QACPmP,EAAU1B,EAAQgB,MAAM,QAAU3Q,GAClC3H,GAASuY,EAAQC,KAAK,IAAMP,GAC5BjY,GAASuY,EAAQC,MACfjB,EAAAA,EAAAA,GAAKD,EAAS1T,EAAKiG,OAAf,QACF+N,OAAQ5X,EACR0Y,MAAOT,GACJM,EAAQI,aAGf3Y,GAASuY,EAAQC,KAAKP,GACtBe,KAGFX,IAEOrY,CACR,EHlDCkY,SAAAA,EACAd,UAAAA,EACA3N,QIbK,SAAiB7F,EAAMjC,EAAG2V,EAASa,GACxC,IAAMsC,EAAOrQ,KAAKiQ,IAAIjQ,KAAKC,IAAI,EAAGzG,EAAK8F,OAAS,GAAI,GAC9C6O,GAAUpK,EAAAA,EAAAA,GAAMgK,GAEtB,GAAIU,EAAsBjV,EAAM0T,GAAU,CACxC,IAAMe,EAAOf,EAAQgB,MAAM,iBACrBU,EAAU1B,EAAQgB,MAAM,YACxBtY,GAAQyY,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QAAC,UAC3BiB,EAAQI,WADkB,IAE7Bf,OAAQ,KACRc,MAAO,QAKT,OAHAM,IACAX,IAGErY,EACA,MACU,IAATya,EAAa,IAAM,KAAKjT,OAEvBxH,EAAMgD,QAGHoH,KAAKiQ,IAAIra,EAAM0a,YAAY,MAAO1a,EAAM0a,YAAY,OAAS,GAGrE,CAED,IAAMN,EAAW,IAAI5S,OAAOiT,GACtBpC,EAAOf,EAAQgB,MAAM,cACrBU,EAAU1B,EAAQgB,MAAM,YAM9BC,EAAQC,KAAK4B,EAAW,KAExB,IAAIpa,GAAQyY,EAAAA,EAAAA,GAAkB7U,EAAM0T,GAAP,QAC3BM,OAAQ,KACRc,MAAO,MACJH,EAAQI,YAqBb,MAlBI,SAAS9S,KAAK7F,KAEhBA,EACE,MACAA,EAAMgC,WAAW,GAAGC,SAAS,IAAI7B,cACjC,IACAJ,EAAMqI,MAAM,IAGhBrI,EAAQA,EAAQoa,EAAW,IAAMpa,EAAQoa,EAErC9C,EAAQvY,QAAQ4b,WAClB3a,GAAS,IAAMoa,GAGjBpB,IACAX,IAEOrY,CACR,EJjDCmR,KAAAA,EACA6B,MAAAA,EACAiG,eAAAA,EACAlP,WAAAA,EAAAA,EACAqD,KAAAA,EACAoM,cAAAA,EACAvO,KKlBK,SAAcrH,EAAMjB,EAAQ2U,EAASa,GAC1C,IAAME,EAAOf,EAAQgB,MAAM,QACrBsC,EAAgBtD,EAAQsD,cAE1BC,EAASjX,EAAK2F,QAAUkQ,EAAmBnC,IAAWwD,EAAAA,EAAAA,GAAYxD,GAEhEyD,EAAcnX,EAAK2F,QCXpB,SAAiC+N,GACtC,IAAMoC,EAAgBD,EAAmBnC,GACnC0D,EAAqB1D,EAAQvY,QAAQic,mBAE3C,IAAKA,EACH,MAAyB,MAAlBtB,EAAwB,IAAM,IAGvC,GAA2B,MAAvBsB,GAAqD,MAAvBA,EAChC,MAAM,IAAIjV,MACR,gCACEiV,EACA,iEAIN,GAAIA,IAAuBtB,EACzB,MAAM,IAAI3T,MACR,8BACE2T,EACA,iCACAsB,EACA,sBAIN,OAAOA,CACR,CDfKC,CAAwB3D,GEZvB,SAA0BA,GAC/B,IAAMuD,GAASC,EAAAA,EAAAA,GAAYxD,GACrByD,EAAczD,EAAQvY,QAAQgc,YAEpC,IAAKA,EACH,MAAkB,MAAXF,EAAiB,IAAM,IAGhC,GAAoB,MAAhBE,GAAuC,MAAhBA,GAAuC,MAAhBA,EAChD,MAAM,IAAIhV,MACR,gCACEgV,EACA,0DAIN,GAAIA,IAAgBF,EAClB,MAAM,IAAI9U,MACR,uBACE8U,EACA,0BACAE,EACA,sBAIN,OAAOA,CACR,CFdKG,CAAiB5D,GACf6D,EAAiB7D,EAAQ6D,eAC3BC,GAAqB,EAczB,GAXEzY,IAECiB,EAAK2F,QACF+N,EAAQvY,QAAQic,mBAChB1D,EAAQvY,QAAQgc,cACpBI,GACAN,IAAWM,IAEXC,GAAqB,IAGlBxX,EAAK2F,QAAS,CACjB,IAAM8R,EAAgBzX,EAAKf,SAAWe,EAAKf,SAAS,QAAKtC,EAqCzD,GAzBc,MAAXsa,GAA6B,MAAXA,IAEnBQ,GACEA,EAAcxY,UAAawY,EAAcxY,SAAS,IAER,SAA5CyU,EAAQK,MAAML,EAAQK,MAAM3U,OAAS,IACO,aAA5CsU,EAAQK,MAAML,EAAQK,MAAM3U,OAAS,IACO,SAA5CsU,EAAQK,MAAML,EAAQK,MAAM3U,OAAS,IACO,aAA5CsU,EAAQK,MAAML,EAAQK,MAAM3U,OAAS,IAEiB,IAAtDsU,EAAQgE,WAAWhE,EAAQgE,WAAWtY,OAAS,IACO,IAAtDsU,EAAQgE,WAAWhE,EAAQgE,WAAWtY,OAAS,IACO,IAAtDsU,EAAQgE,WAAWhE,EAAQgE,WAAWtY,OAAS,KAE/CoY,GAAqB,GAWnBzB,EAAUrC,KAAauD,GAAUQ,EAGnC,IAFA,IAAItY,GAAS,IAEJA,EAAQa,EAAKf,SAASG,QAAQ,CACrC,IAAMuY,EAAO3X,EAAKf,SAASE,GAE3B,GACEwY,GACc,aAAdA,EAAKrY,MACLqY,EAAK1Y,UACL0Y,EAAK1Y,SAAS,IACY,kBAA1B0Y,EAAK1Y,SAAS,GAAGK,KACjB,CACAkY,GAAqB,EACrB,KACD,CACF,CAEJ,CAEGA,IACFP,EAASE,GAGXzD,EAAQsD,cAAgBC,EACxB,IAAM7a,GAAQga,EAAAA,EAAAA,GAAcpW,EAAM0T,EAASa,GAI3C,OAHAb,EAAQ6D,eAAiBN,EACzBvD,EAAQsD,cAAgBA,EACxBvC,IACOrY,CACR,ELzECwb,SAAAA,EAAAA,EACAC,UQzBK,SAAmB7X,EAAMjC,EAAG2V,EAASa,GAC1C,IAAME,EAAOf,EAAQgB,MAAM,aACrBU,EAAU1B,EAAQgB,MAAM,YACxBtY,GAAQyY,EAAAA,EAAAA,GAAkB7U,EAAM0T,EAASa,GAG/C,OAFAa,IACAX,IACOrY,CACR,ERmBC+L,KS1BK,SAAcnI,EAAMjC,EAAG2V,EAASa,GACrC,OAAO6B,EAAAA,EAAAA,GAAcpW,EAAM0T,EAASa,EACrC,ETyBC3M,OAAAA,EACAS,KU5BK,SAAcrI,EAAMjC,EAAG2V,EAASa,GACrC,OAAOZ,EAAAA,EAAAA,GAAKD,EAAS1T,EAAK5D,MAAOmY,EAClC,EV2BCuD,cW5BK,SAAuB/Z,EAAG0V,EAAIC,GACnC,IAAMtX,GACJ2Z,EAAUrC,IAAYA,EAAQvY,QAAQ4c,WAAa,IAAM,KACzDnU,OCNG,SAA6B8P,GAClC,IAAMsE,EAAatE,EAAQvY,QAAQ8c,gBAAkB,EAErD,GAAID,EAAa,EACf,MAAM,IAAI7V,MACR,2CACE6V,EACA,wDAIN,OAAOA,CACR,CDNUE,CAAoBxE,IAE7B,OAAOA,EAAQvY,QAAQ4c,WAAa3b,EAAMqI,MAAM,GAAI,GAAKrI,CAC1D,GEVYyH,EAAO,CAGpB,SAAsBsU,EAAMC,EAAOrZ,EAAQ2U,GAEzC,GACiB,SAAf0E,EAAM9Y,MACN2U,EAAqBmE,EAAO1E,KACb,SAAdyE,EAAK7Y,MACH6Y,EAAK7Y,OAAS8Y,EAAM9Y,MAAQ2U,EAAqBkE,EAAMzE,IAE1D,OAAO,EAIT,GACgB,SAAdyE,EAAK7Y,MACL6Y,EAAK7Y,OAAS8Y,EAAM9Y,MACpBwD,QAAQqV,EAAKxS,WAAa7C,QAAQsV,EAAMzS,YACtCwS,EAAKxS,QACH+N,EAAQvY,QAAQic,mBAChB1D,EAAQvY,QAAQgc,aAEpB,OAAO,EAKT,GAAI,WAAYpY,GAAmC,mBAAlBA,EAAOqG,OAAsB,CAC5D,GACgB,cAAd+S,EAAK7Y,OAEJ6Y,EAAK7Y,OAAS8Y,EAAM9Y,MACJ,eAAf8Y,EAAM9Y,MAEU,YAAf8Y,EAAM9Y,MAAsB2V,EAAsBmD,EAAO1E,IAE5D,OAGF,OAAO3U,EAAOqG,OAAS,EAAI,CAC5B,CACF,GCxCD,IAAMiT,EAAoB,CACxB,WACA,qBACA,iBACA,YACA,aACA,mBAIWzE,EAAS,CACpB,CAACC,UAAW,KAAMiB,MAAO,WAAYwD,YAAa,YAClD,CAACzE,UAAW,KAAMG,OAAQ,WAAYsE,YAAa,YACnD,CACEzE,UAAW,KACXyE,YAAa,CAAC,4BAA6B,wBAE7C,CACEzE,UAAW,KACXyE,YAAa,CACX,4BACA,sBACA,4BACA,sBACA,qBACA,eAGJ,CACEzE,UAAW,KACXyE,YAAa,CACX,4BACA,sBACA,4BACA,sBACA,qBACA,eAGJ,CAACzE,UAAW,IAAKiB,MAAO,WAAYwD,YAAa,YACjD,CAACzE,UAAW,IAAKG,OAAQ,WAAYsE,YAAa,YAClD,CACEzE,UAAW,IACXyE,YAAa,CAAC,4BAA6B,wBAI7C,CACEzE,UAAW,IACXiB,MAAO,MACPwD,YAAa,WACbC,eAAgBF,GAGlB,CAACxE,UAAW,IAAKyE,YAAa,cAE9B,CAACE,SAAS,EAAM3E,UAAW,KAC3B,CAACA,UAAW,IAAKyE,YAAa,aAAcxD,MAAO,gBAGnD,CAACjB,UAAW,IAAKiB,MAAO,YAAawD,YAAa,YAElD,CAACzE,UAAW,IAAKyE,YAAa,mBAE9B,CAACzE,UAAW,IAAKyE,YAAa,kBAE9B,CACEtE,OAAQ,MACRH,UAAW,IACXyE,YAAa,WACbC,eAAgBF,GAIlB,CAACG,SAAS,EAAMxE,OAAQ,OAAQH,UAAW,KAC3C,CAACA,UAAW,IAAKyE,YAAa,kBAE9B,CAACE,SAAS,EAAM3E,UAAW,KAC3B,CAACA,UAAW,IAAKyE,YAAa,WAAYC,eAAgBF,GAE1D,CAACG,SAAS,EAAM3E,UAAW,KAG3B,CAAC2E,SAAS,EAAM3E,UAAW,KAE3B,CAAC2E,SAAS,EAAMxE,OAAQ,OAAQH,UAAW,IAAKiB,MAAO,mBAOvD,CAAC0D,SAAS,EAAM3E,UAAW,IAAKiB,MAAO,eACvC,CACEjB,UAAW,IACXiB,MAAO,cACPwD,YAAa,WACbC,eAAgBF,GAElB,CAACxE,UAAW,IAAKyE,YAAa,sBAE9B,CAACE,SAAS,EAAM3E,UAAW,KAG3B,CAAC2E,SAAS,EAAM3E,UAAW,KAC3B,CAACA,UAAW,IAAKyE,YAAa,sBAG9B,CAACE,SAAS,EAAM3E,UAAW,KAC3B,CAACA,UAAW,IAAKyE,YAAa,WAAYC,eAAgBF,GAC1D,CAACxE,UAAW,IAAKyE,YAAa,CAAC,QAAS,cAIxC,CAACzE,UAAW,KAAMiB,MAAO,WAAYwD,YAAa,YAElD,CAACzE,UAAW,IAAKyE,YAAa,CAAC,QAAS,cAGxC,CAACE,SAAS,EAAM3E,UAAW,KAC3B,CAACA,UAAW,IAAKyE,YAAa,WAAYC,eAAgBF,GAG1D,CAACG,SAAS,EAAM3E,UAAW,KAC3B,CACEA,UAAW,IACXyE,YAAa,CAAC,4BAA6B,8BAE7C,CAACzE,UAAW,IAAKyE,YAAa,WAAYC,eAAgBF,GAI1D,CAACG,SAAS,EAAM3E,UAAW,MC7D7B,SAAS4E,EAAQrc,GACf,MAAM,IAAI+F,MAAM,wBAA0B/F,EAAQ,mBACnD,CAMD,SAASiE,EAAQL,GACf,MAAM,IAAImC,MAAM,+BAAiCnC,EAAKV,KAAO,IAC9D,CAGD,SAASoZ,EAAeP,EAAMC,GAE5B,GAAkB,eAAdD,EAAK7Y,MAAyB6Y,EAAK7Y,OAAS8Y,EAAM9Y,KACpD,OAAO,CAEV,CCjGD,MCOe,SAAyBnE,GAAS,WAoB/CK,OAAOC,OAAOJ,KAAM,CAACsd,SAlBJ,SAACxG,GAEhB,IAAM5W,EAAmC,EAAKD,KAAK,YAEnD,OFKG,SAAoB6W,GAAoB,IAAdhX,EAAc,uDAAJ,CAAC,EAGpCuY,EAAU,CACdgB,MAAAA,EACAX,MAAO,GACPH,OAAQ,GACR/P,KAAM,GACNzD,SAAU,CAAC,EACXjF,QAAS,CAAC,EACVuc,WAAY,IAGdvE,EAAUO,EAAS,CAACE,OAAAA,EAAQ/P,KAAAA,EAAMzD,SAAUsF,IAC5CyN,EAAUO,EAASvY,GAEfuY,EAAQvY,QAAQyd,kBAClBzF,EAAUO,EAAS,CAAC7P,KAAM,CAAC6U,KAI7BhF,EAAQhO,QAASmT,EAAAA,EAAAA,GAAO,OAAQ,CAC9BJ,QAAAA,EAEApY,QAAAA,EAEAD,SAAUsT,EAAQtT,WAGpB,IAAIZ,EAASkU,EAAQhO,OAAOyM,EAAM,KAAMuB,EAAS,CAC/CM,OAAQ,KACRc,MAAO,KACPgE,IAAK,CAAChc,KAAM,EAAGE,OAAQ,GACvB+b,UAAW,IAWb,OAPEvZ,GACyC,KAAzCA,EAAOpB,WAAWoB,EAAOJ,OAAS,IACO,KAAzCI,EAAOpB,WAAWoB,EAAOJ,OAAS,KAElCI,GAAU,MAGLA,EAGP,SAASkV,EAAMvY,GAEb,OADAuX,EAAQK,MAAMnU,KAAKzD,GAGnB,WACEuX,EAAQK,MAAMiF,KACf,CACF,CACF,CE5DUC,CACL9G,EACA3W,OAAOC,OAAO,CAAC,EAAGF,EAAUJ,EAAS,CAInCmY,WAEI,EAAKhY,KAAK,yBACP,KAGZ,GAGF,C","sources":["../../node_modules/rehype-parse/lib/errors.js","../../node_modules/rehype-parse/lib/index.js","../../node_modules/hast-util-to-mdast/lib/all.js","../../node_modules/hast-util-to-mdast/lib/util/own.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-text.js","../../node_modules/hast-util-to-mdast/lib/one.js","../../node_modules/mdast-util-phrasing/index.js","../../node_modules/hast-util-to-mdast/lib/util/wrap.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-children.js","../../node_modules/hast-util-to-mdast/lib/util/resolve.js","../../node_modules/unist-util-find-after/index.js","../../node_modules/hast-util-to-text/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/code.js","../../node_modules/trim-trailing-lines/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/del.js","../../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../../node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js","../../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../../node_modules/hast-util-to-mdast/lib/handlers/em.js","../../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../../node_modules/hast-util-to-mdast/lib/handlers/img.js","../../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../../node_modules/hast-util-to-mdast/lib/handlers/input.js","../../node_modules/hast-util-to-mdast/lib/handlers/li.js","../../node_modules/hast-util-to-mdast/lib/handlers/list.js","../../node_modules/hast-util-to-mdast/lib/handlers/media.js","../../node_modules/hast-util-to-mdast/lib/handlers/p.js","../../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../../node_modules/hast-util-to-mdast/lib/handlers/table.js","../../node_modules/hast-util-to-mdast/lib/handlers/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/root.js","../../node_modules/hast-util-to-mdast/lib/handlers/text.js","../../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../../node_modules/hast-util-to-mdast/lib/handlers/a.js","../../node_modules/hast-util-to-mdast/lib/handlers/base.js","../../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../../node_modules/hast-util-to-mdast/lib/handlers/br.js","../../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../../node_modules/hast-util-to-mdast/lib/handlers/q.js","../../node_modules/hast-util-to-mdast/lib/handlers/select.js","../../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../../node_modules/hast-util-to-mdast/lib/index.js","../../node_modules/rehype-remark/lib/index.js","../../node_modules/mdast-util-to-markdown/lib/configure.js","../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../node_modules/mdast-util-to-markdown/lib/handle/index.js","../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../node_modules/longest-streak/index.js","../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../node_modules/mdast-util-to-markdown/lib/join.js","../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../node_modules/mdast-util-to-markdown/lib/index.js","../../node_modules/remark-stringify/index.js","../../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["export const errors = {\n  abandonedHeadElementChild: {\n    reason: 'Unexpected metadata element after head',\n    description:\n      'Unexpected element after head. Expected the element before `</head>`',\n    url: false\n  },\n  abruptClosingOfEmptyComment: {\n    reason: 'Unexpected abruptly closed empty comment',\n    description: 'Unexpected `>` or `->`. Expected `-->` to close comments'\n  },\n  abruptDoctypePublicIdentifier: {\n    reason: 'Unexpected abruptly closed public identifier',\n    description:\n      'Unexpected `>`. Expected a closing `\"` or `\\'` after the public identifier'\n  },\n  abruptDoctypeSystemIdentifier: {\n    reason: 'Unexpected abruptly closed system identifier',\n    description:\n      'Unexpected `>`. Expected a closing `\"` or `\\'` after the identifier identifier'\n  },\n  absenceOfDigitsInNumericCharacterReference: {\n    reason: 'Unexpected non-digit at start of numeric character reference',\n    description:\n      'Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references'\n  },\n  cdataInHtmlContent: {\n    reason: 'Unexpected CDATA section in HTML',\n    description:\n      'Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead'\n  },\n  characterReferenceOutsideUnicodeRange: {\n    reason: 'Unexpected too big numeric character reference',\n    description:\n      'Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)'\n  },\n  closingOfElementWithOpenChildElements: {\n    reason: 'Unexpected closing tag with open child elements',\n    description:\n      'Unexpectedly closing tag. Expected other tags to be closed first',\n    url: false\n  },\n  controlCharacterInInputStream: {\n    reason: 'Unexpected control character',\n    description:\n      'Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace'\n  },\n  controlCharacterReference: {\n    reason: 'Unexpected control character reference',\n    description:\n      'Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace'\n  },\n  disallowedContentInNoscriptInHead: {\n    reason: 'Disallowed content inside `<noscript>` in `<head>`',\n    description:\n      'Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`',\n    url: false\n  },\n  duplicateAttribute: {\n    reason: 'Unexpected duplicate attribute',\n    description:\n      'Unexpectedly double attribute. Expected attributes to occur only once'\n  },\n  endTagWithAttributes: {\n    reason: 'Unexpected attribute on closing tag',\n    description: 'Unexpected attribute. Expected `>` instead'\n  },\n  endTagWithTrailingSolidus: {\n    reason: 'Unexpected slash at end of closing tag',\n    description: 'Unexpected `%c-1`. Expected `>` instead'\n  },\n  endTagWithoutMatchingOpenElement: {\n    reason: 'Unexpected unopened end tag',\n    description: 'Unexpected end tag. Expected no end tag or another end tag',\n    url: false\n  },\n  eofBeforeTagName: {\n    reason: 'Unexpected end of file',\n    description: 'Unexpected end of file. Expected tag name instead'\n  },\n  eofInCdata: {\n    reason: 'Unexpected end of file in CDATA',\n    description: 'Unexpected end of file. Expected `]]>` to close the CDATA'\n  },\n  eofInComment: {\n    reason: 'Unexpected end of file in comment',\n    description: 'Unexpected end of file. Expected `-->` to close the comment'\n  },\n  eofInDoctype: {\n    reason: 'Unexpected end of file in doctype',\n    description:\n      'Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)'\n  },\n  eofInElementThatCanContainOnlyText: {\n    reason: 'Unexpected end of file in element that can only contain text',\n    description: 'Unexpected end of file. Expected text or a closing tag',\n    url: false\n  },\n  eofInScriptHtmlCommentLikeText: {\n    reason: 'Unexpected end of file in comment inside script',\n    description: 'Unexpected end of file. Expected `-->` to close the comment'\n  },\n  eofInTag: {\n    reason: 'Unexpected end of file in tag',\n    description: 'Unexpected end of file. Expected `>` to close the tag'\n  },\n  incorrectlyClosedComment: {\n    reason: 'Incorrectly closed comment',\n    description: 'Unexpected `%c-1`. Expected `-->` to close the comment'\n  },\n  incorrectlyOpenedComment: {\n    reason: 'Incorrectly opened comment',\n    description: 'Unexpected `%c`. Expected `<!--` to open the comment'\n  },\n  invalidCharacterSequenceAfterDoctypeName: {\n    reason: 'Invalid sequence after doctype name',\n    description: 'Unexpected sequence at `%c`. Expected `public` or `system`'\n  },\n  invalidFirstCharacterOfTagName: {\n    reason: 'Invalid first character in tag name',\n    description: 'Unexpected `%c`. Expected an ASCII letter instead'\n  },\n  misplacedDoctype: {\n    reason: 'Misplaced doctype',\n    description: 'Unexpected doctype. Expected doctype before head',\n    url: false\n  },\n  misplacedStartTagForHeadElement: {\n    reason: 'Misplaced `<head>` start tag',\n    description:\n      'Unexpected start tag `<head>`. Expected `<head>` directly after doctype',\n    url: false\n  },\n  missingAttributeValue: {\n    reason: 'Missing attribute value',\n    description:\n      'Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead'\n  },\n  missingDoctype: {\n    reason: 'Missing doctype before other content',\n    description: 'Expected a `<!doctype html>` before anything else',\n    url: false\n  },\n  missingDoctypeName: {\n    reason: 'Missing doctype name',\n    description: 'Unexpected doctype end at `%c`. Expected `html` instead'\n  },\n  missingDoctypePublicIdentifier: {\n    reason: 'Missing public identifier in doctype',\n    description: 'Unexpected `%c`. Expected identifier for `public` instead'\n  },\n  missingDoctypeSystemIdentifier: {\n    reason: 'Missing system identifier in doctype',\n    description:\n      'Unexpected `%c`. Expected identifier for `system` instead (suggested: `\"about:legacy-compat\"`)'\n  },\n  missingEndTagName: {\n    reason: 'Missing name in end tag',\n    description: 'Unexpected `%c`. Expected an ASCII letter instead'\n  },\n  missingQuoteBeforeDoctypePublicIdentifier: {\n    reason: 'Missing quote before public identifier in doctype',\n    description: 'Unexpected `%c`. Expected `\"` or `\\'` instead'\n  },\n  missingQuoteBeforeDoctypeSystemIdentifier: {\n    reason: 'Missing quote before system identifier in doctype',\n    description: 'Unexpected `%c`. Expected `\"` or `\\'` instead'\n  },\n  missingSemicolonAfterCharacterReference: {\n    reason: 'Missing semicolon after character reference',\n    description: 'Unexpected `%c`. Expected `;` instead'\n  },\n  missingWhitespaceAfterDoctypePublicKeyword: {\n    reason: 'Missing whitespace after public identifier in doctype',\n    description: 'Unexpected `%c`. Expected ASCII whitespace instead'\n  },\n  missingWhitespaceAfterDoctypeSystemKeyword: {\n    reason: 'Missing whitespace after system identifier in doctype',\n    description: 'Unexpected `%c`. Expected ASCII whitespace instead'\n  },\n  missingWhitespaceBeforeDoctypeName: {\n    reason: 'Missing whitespace before doctype name',\n    description: 'Unexpected `%c`. Expected ASCII whitespace instead'\n  },\n  missingWhitespaceBetweenAttributes: {\n    reason: 'Missing whitespace between attributes',\n    description: 'Unexpected `%c`. Expected ASCII whitespace instead'\n  },\n  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {\n    reason:\n      'Missing whitespace between public and system identifiers in doctype',\n    description: 'Unexpected `%c`. Expected ASCII whitespace instead'\n  },\n  nestedComment: {\n    reason: 'Unexpected nested comment',\n    description: 'Unexpected `<!--`. Expected `-->`'\n  },\n  nestedNoscriptInHead: {\n    reason: 'Unexpected nested `<noscript>` in `<head>`',\n    description:\n      'Unexpected `<noscript>`. Expected a closing tag or a meta element',\n    url: false\n  },\n  nonConformingDoctype: {\n    reason: 'Unexpected non-conforming doctype declaration',\n    description:\n      'Expected `<!doctype html>` or `<!doctype html system \"about:legacy-compat\">`',\n    url: false\n  },\n  nonVoidHtmlElementStartTagWithTrailingSolidus: {\n    reason: 'Unexpected trailing slash on start tag of non-void element',\n    description: 'Unexpected `/`. Expected `>` instead'\n  },\n  noncharacterCharacterReference: {\n    reason:\n      'Unexpected noncharacter code point referenced by character reference',\n    description: 'Unexpected code point. Do not use noncharacters in HTML'\n  },\n  noncharacterInInputStream: {\n    reason: 'Unexpected noncharacter character',\n    description: 'Unexpected code point `%x`. Do not use noncharacters in HTML'\n  },\n  nullCharacterReference: {\n    reason: 'Unexpected NULL character referenced by character reference',\n    description: 'Unexpected code point. Do not use NULL characters in HTML'\n  },\n  openElementsLeftAfterEof: {\n    reason: 'Unexpected end of file',\n    description: 'Unexpected end of file. Expected closing tag instead',\n    url: false\n  },\n  surrogateCharacterReference: {\n    reason: 'Unexpected surrogate character referenced by character reference',\n    description:\n      'Unexpected code point. Do not use lone surrogate characters in HTML'\n  },\n  surrogateInInputStream: {\n    reason: 'Unexpected surrogate character',\n    description:\n      'Unexpected code point `%x`. Do not use lone surrogate characters in HTML'\n  },\n  unexpectedCharacterAfterDoctypeSystemIdentifier: {\n    reason: 'Invalid character after system identifier in doctype',\n    description: 'Unexpected character at `%c`. Expected `>`'\n  },\n  unexpectedCharacterInAttributeName: {\n    reason: 'Unexpected character in attribute name',\n    description:\n      'Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter'\n  },\n  unexpectedCharacterInUnquotedAttributeValue: {\n    reason: 'Unexpected character in unquoted attribute value',\n    description: 'Unexpected `%c`. Quote the attribute value to include it'\n  },\n  unexpectedEqualsSignBeforeAttributeName: {\n    reason: 'Unexpected equals sign before attribute name',\n    description: 'Unexpected `%c`. Add an attribute name before it'\n  },\n  unexpectedNullCharacter: {\n    reason: 'Unexpected NULL character',\n    description:\n      'Unexpected code point `%x`. Do not use NULL characters in HTML'\n  },\n  unexpectedQuestionMarkInsteadOfTagName: {\n    reason: 'Unexpected question mark instead of tag name',\n    description: 'Unexpected `%c`. Expected an ASCII letter instead'\n  },\n  unexpectedSolidusInTag: {\n    reason: 'Unexpected slash in tag',\n    description:\n      'Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value'\n  },\n  unknownNamedCharacterReference: {\n    reason: 'Unexpected unknown named character reference',\n    description:\n      'Unexpected character reference. Expected known named character references'\n  }\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {Pick<import('hast-util-from-parse5').Options, 'space' | 'verbose'>} FromParse5Options\n *\n * @typedef {keyof errors} ErrorCode\n * @typedef {0|1|2|boolean|null|undefined} ErrorSeverity\n * @typedef {Partial<Record<ErrorCode, ErrorSeverity>>} ErrorFields\n *\n * @typedef ParseFields\n * @property {boolean|undefined} [fragment=false]\n *   Specify whether to parse a fragment, instead of a complete document.\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n * @property {boolean|undefined} [emitParseErrors=false]\n *   > ⚠️ Parse errors are currently being added to HTML.\n *   > Not all errors emitted by parse5 (or rehype-parse) are specced yet.\n *   > Some documentation may still be missing.\n *\n *   Emit parse errors while parsing on the vfile.\n *   Setting this to `true` starts emitting HTML parse errors.\n *\n *   Specific rules can be turned off by setting them to `false` (or `0`).\n *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means\n *   that rules emit as warnings.\n *   Rules can also be configured with `2`, to turn them into fatal errors.\n *\n * @typedef {FromParse5Options & ParseFields & ErrorFields} Options\n */\n\n// @ts-expect-error: remove when typed\nimport Parser5 from 'parse5/lib/parser/index.js'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {errors} from './errors.js'\n\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-'\n\nconst fatalities = {2: true, 1: false, 0: null}\n\n/** @type {import('unified').Plugin<[Options?] | Array<void>, string, Root>} */\nexport default function rehypeParse(options) {\n  const processorSettings = /** @type {Options} */ (this.data('settings'))\n  const settings = Object.assign({}, processorSettings, options)\n\n  Object.assign(this, {Parser: parser})\n\n  /** @type {import('unified').ParserFunction<Root>} */\n  function parser(doc, file) {\n    const fn = settings.fragment ? 'parseFragment' : 'parse'\n    const onParseError = settings.emitParseErrors ? onerror : null\n    const parse5 = new Parser5({\n      sourceCodeLocationInfo: true,\n      onParseError,\n      scriptingEnabled: false\n    })\n\n    // @ts-expect-error: `parse5` returns document or fragment, which are always\n    // mapped to roots.\n    return fromParse5(parse5[fn](doc), {\n      space: settings.space,\n      file,\n      verbose: settings.verbose\n    })\n\n    /**\n     * @param {{code: string, startLine: number, startCol: number, startOffset: number, endLine: number, endCol: number, endOffset: number}} error\n     */\n    function onerror(error) {\n      const code = error.code\n      const name = camelcase(code)\n      const setting = settings[name]\n      const config = setting === undefined || setting === null ? true : setting\n      const level = typeof config === 'number' ? config : config ? 1 : 0\n      const start = {\n        line: error.startLine,\n        column: error.startCol,\n        offset: error.startOffset\n      }\n      const end = {\n        line: error.endLine,\n        column: error.endCol,\n        offset: error.endOffset\n      }\n      if (level) {\n        /* c8 ignore next */\n        const info = errors[name] || {reason: '', description: '', url: ''}\n        const message = file.message(format(info.reason), {start, end})\n        message.source = 'parse-error'\n        message.ruleId = code\n        message.fatal = fatalities[level]\n        message.note = format(info.description)\n        message.url = 'url' in info && info.url === false ? null : base + code\n      }\n\n      /**\n       * @param {string} value\n       * @returns {string}\n       */\n      function format(value) {\n        return value\n          .replace(/%c(?:-(\\d+))?/g, (_, /** @type {string} */ $1) => {\n            const offset = $1 ? -Number.parseInt($1, 10) : 0\n            const char = doc.charAt(error.startOffset + offset)\n            return char === '`' ? '` ` `' : char\n          })\n          .replace(\n            /%x/g,\n            () =>\n              '0x' +\n              doc.charCodeAt(error.startOffset).toString(16).toUpperCase()\n          )\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {ErrorCode}\n */\nfunction camelcase(value) {\n  // @ts-expect-error: this returns a valid error code.\n  return value.replace(/-[a-z]/g, ($0) => $0.charAt(1).toUpperCase())\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {one} from './one.js'\n\n/**\n * @param {H} h\n * @param {Node} parent\n * @returns {Array<MdastNode>}\n */\nexport function all(h, parent) {\n  /** @type {Array<Node>} */\n  // @ts-expect-error Assume `parent` is a parent.\n  const nodes = parent.children || []\n  /** @type {Array<MdastNode>} */\n  const values = []\n  let index = -1\n  let length = nodes.length\n  let child = nodes[index + 1]\n\n  // Trim initial and final `<br>`s.\n  // They’re not semantic per HTML, and they can’t be made in markdown things\n  // like paragraphs or headings.\n  while (child && child.type === 'element' && child.tagName === 'br') {\n    index++\n    child = nodes[index + 1]\n  }\n\n  child = nodes[length - 1]\n\n  while (\n    length - 1 > index &&\n    child &&\n    child.type === 'element' &&\n    child.tagName === 'br'\n  ) {\n    length--\n    child = nodes[length - 1]\n  }\n\n  while (++index < length) {\n    // @ts-expect-error assume `parent` is a parent.\n    const result = one(h, nodes[index], parent)\n\n    if (Array.isArray(result)) {\n      values.push(...result)\n    } else if (result) {\n      values.push(result)\n    }\n  }\n\n  return values\n}\n","export const own = {}.hasOwnProperty\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string} value\n * @returns {string}\n */\nexport function wrapText(h, value) {\n  return h.wrapText ? value : value.replace(/\\r?\\n|\\r/g, ' ')\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {all} from './all.js'\nimport {own} from './util/own.js'\nimport {wrapText} from './util/wrap-text.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @param {Parent|undefined} parent\n * @returns {MdastNode|Array<MdastNode>|void}\n */\nexport function one(h, node, parent) {\n  /** @type {Handle|undefined} */\n  let fn\n\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(h.handlers, node.tagName)) {\n      fn = h.handlers[node.tagName]\n    }\n  } else if (own.call(h.handlers, node.type)) {\n    fn = h.handlers[node.type]\n  }\n\n  if (typeof fn === 'function') {\n    return fn(h, node, parent)\n  }\n\n  return unknown(h, node)\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(h, node) {\n  // @ts-expect-error: Looks like a literal.\n  if (typeof node.value === 'string') {\n    // @ts-expect-error: Looks like a literal.\n    return h(node, 'text', wrapText(h, node.value))\n  }\n\n  return all(h, node)\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * @type {AssertPredicatePhrasing}\n */\n// @ts-ignore hush, it’s fine!\nexport const phrasing = convert([\n  'break',\n  'delete',\n  'emphasis',\n  'footnote',\n  'footnoteReference',\n  'image',\n  'imageReference',\n  'inlineCode',\n  'link',\n  'linkReference',\n  'strong',\n  'text'\n])\n","/**\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n */\n\nimport extend from 'extend'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Array<MdastNode>} nodes\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing)\n\n  /**\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode|Array<MdastNode>}\n   */\n  function onphrasing(nodes) {\n    const head = nodes[0]\n\n    if (\n      nodes.length === 1 &&\n      head.type === 'text' &&\n      (head.value === ' ' || head.value === '\\n')\n    ) {\n      return []\n    }\n\n    return {type: 'paragraph', children: nodes}\n  }\n}\n\n/**\n * Check if there are non-phrasing mdast nodes returned.\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @param {(nodes: Array<MdastPhrasingContent>) => MdastNode|Array<MdastNode>} onphrasing\n * @param {(node: MdastNode) => MdastNode} [onnonphrasing]\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const nonphrasing = onnonphrasing || identity\n  /** @type {Array<MdastNode>} */\n  const flattened = flatten(nodes)\n  /** @type {Array<MdastNode>} */\n  let result = []\n  let index = -1\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < flattened.length) {\n    node = flattened[index]\n\n    if (phrasing(node)) {\n      if (!queue) queue = []\n      queue.push(node)\n    } else {\n      if (queue) {\n        result = result.concat(onphrasing(queue))\n        queue = undefined\n      }\n\n      result = result.concat(nonphrasing(node))\n    }\n  }\n\n  if (queue) {\n    result = result.concat(onphrasing(queue))\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {Array<MdastNode>}\n */\nfunction flatten(nodes) {\n  /** @type {Array<MdastNode>} */\n  let flattened = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened = flattened.concat(split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * @param {MdastNode} node\n * @returns {Array<MdastNode>}\n */\nfunction split(node) {\n  // @ts-expect-error Assume parent.\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {MdastNode} child\n   * @returns {MdastNode}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const {children, ...rest} = node\n      return {\n        ...child,\n        // @ts-expect-error: assume matching parent & child.\n        children: [{...extend(true, {}, rest), children: child.children}]\n      }\n    }\n\n    return {...child}\n  }\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode}\n   */\n  function onphrasing(nodes) {\n    // @ts-expect-error: assume parent.\n    const {children, ...rest} = node\n    // @ts-expect-error: assume matching parent & child.\n    return {...extend(true, {}, rest), children: nodes}\n  }\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {MdastNode} node\n * @returns {node is MdastPhrasingContent}\n */\nfunction phrasing(node) {\n  return node.data && node.data.hName\n    ? hastPhrasing({\n        type: 'element',\n        tagName: node.data.hName,\n        properties: {},\n        children: []\n      })\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {unknown} T\n * @param {T} n\n * @returns {T}\n */\nfunction identity(n) {\n  return n\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\nimport {wrap} from './wrap.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @returns {Array<MdastNode>}\n */\nexport function wrapChildren(h, node) {\n  return wrap(all(h, node))\n}\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string|null|undefined} url\n * @returns {string}\n */\nexport function resolve(h, url) {\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (h.frozenBaseUrl) {\n    return String(new URL(url, h.frozenBaseUrl))\n  }\n\n  return url\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport {convert} from 'unist-util-is'\n\nexport var findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n   *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent Parent node\n     * @param {Node|number} index Child of `parent`, or it’s index\n     * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n     * @returns {Node|null}\n     */\n    function (parent, index, test) {\n      var is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n","/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber|undefined} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce|undefined} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @param {Options} [options={}]\n * @returns {string}\n */\nexport function toText(node, options = {}) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  const children = node.children || []\n  const block = blockOrCaption(node)\n  const whitespace = inferWhitespace(node, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let results\n  /** @type {string|BreakNumber} */\n  let value\n  /** @type {number|undefined} */\n  let count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {whitespace, breakBefore: true, breakAfter: true})\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      // @ts-ignore Looks like a parent.\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  /** @type {Array.<string>} */\n  const result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push('\\n'.repeat(count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whitespace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node)\n    ]\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, options)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let items = []\n  /** @type {BreakNumber|undefined} */\n  let prefix\n  /** @type {BreakNumber|BreakForce|undefined} */\n  let suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\nfunction collectText(node, options) {\n  const value = String(node.value)\n  /** @type {Array.<string>} */\n  const lines = []\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  let index = -1\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n  /** @type {string|undefined} */\n  let join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  // @ts-expect-error: `end` is defined.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  let props\n\n  if (node.type === 'element') {\n    props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return options.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst prefix = 'language-'\n\nconst pre = convertElement('pre')\nconst isCode = convertElement('code')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function code(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<string|number>|undefined} */\n  let classList\n  /** @type {string|undefined} */\n  let lang\n\n  if (pre(node)) {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        isCode(child) &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  return h(\n    node,\n    'code',\n    {lang: lang || null, meta: null},\n    trimTrailingLines(wrapText(h, toText(node)))\n  )\n}\n","/**\n * Remove final newline characters from `value`.\n *\n * @param {unknown} value Value with trailing line feeds, coerced to string.\n * @return {string} Value without trailing newlines.\n */\nexport function trimTrailingLines(value) {\n  return String(value).replace(/\\n+$/, '')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function del(h, node) {\n  return h(node, 'delete', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\n/**\n * @param {Array<MdastListContent>} children\n * @returns {boolean}\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\nimport {all} from '../all.js'\n\n/**\n * @param {H} h\n * @param {Child} node\n * @returns {Array<MdastListContent>}\n */\nexport function wrapListItems(h, node) {\n  const children = all(h, node)\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (child.type !== 'listItem') {\n      children[index] = {\n        type: 'listItem',\n        spread: false,\n        checked: null,\n        // @ts-expect-error Assume `children[index]` is block content.\n        children: [child]\n      }\n    }\n  }\n\n  // @ts-expect-error Assume all `listItem`s\n  return children\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n * @typedef {import('../types.js').MdastBlockContent} MdastBlockContent\n * @typedef {import('../types.js').MdastDefinitionContent} MdastDefinitionContent\n *\n * @typedef Group\n * @property {Array<Element>} titles\n * @property {Array<ElementChild>} definitions\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst div = convertElement('div')\nconst dt = convertElement('dt')\nconst dd = convertElement('dd')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function dl(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<ElementChild>} */\n  let clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  /** @type {Group} */\n  let group = {titles: [], definitions: []}\n  /** @type {ElementChild} */\n  let child\n  /** @type {Array<MdastBlockContent|MdastDefinitionContent>} */\n  let result\n\n  // Unwrap `<div>`s\n  while (++index < children.length) {\n    child = children[index]\n    clean = clean.concat(div(child) ? child.children : child)\n  }\n\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    child = clean[index]\n\n    if (dt(child)) {\n      if (dd(clean[index - 1])) {\n        groups.push(group)\n        group = {titles: [], definitions: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<MdastListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    result = [\n      ...handle(h, groups[index].titles),\n      ...handle(h, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    return h(\n      node,\n      'list',\n      {ordered: false, start: null, spread: listItemsSpread(content)},\n      content\n    )\n  }\n}\n\n/**\n * @param {H} h\n * @param {Array<ElementChild>} children\n * @returns {Array<MdastBlockContent|MdastDefinitionContent>}\n */\nfunction handle(h, children) {\n  const nodes = wrapListItems(h, {type: 'element', tagName: 'x', children})\n\n  if (nodes.length === 0) {\n    return []\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(nodes),\n      children: nodes\n    }\n  ]\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function em(h, node) {\n  return h(node, 'emphasis', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function heading(h, node) {\n  // `else` shouldn’t happen, of course…\n  /* c8 ignore next */\n  const depth = Number(node.tagName.charAt(1)) || 1\n  const wrap = h.wrapText\n\n  h.wrapText = false\n  const result = h(node, 'heading', {depth}, all(h, node))\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function img(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(node, 'image', {\n    url: resolve(h, String(props.src || '') || null),\n    title: props.title || null,\n    alt: props.alt || ''\n  })\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function inlineCode(h, node) {\n  return h(node, 'inlineCode', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {hasProperty} from 'hast-util-has-property'\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from './wrap-text.js'\n\nconst option = convertElement('option')\n\n/**\n * @param {H} h\n * @param {Element} node\n * @param {Properties} [properties]\n * @returns {Array<[string, string|null]>}\n */\nexport function findSelectedOptions(h, node, properties) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` exist.\n  const props = properties || node.properties\n  let options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(props.size), 10), 0) ||\n    (props.multiple ? 4 : 1)\n  let index = -1\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Array<[string, string|null]>} */\n  const values = []\n\n  while (++index < options.length) {\n    if (hasProperty(options[index], 'selected')) {\n      selectedOptions.push(options[index])\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  options = list.slice(0, size)\n  index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n    const content = wrapText(h, toText(option))\n    /** @type {Properties} */\n    // @ts-expect-error: `props` exist.\n    const props = option.properties\n    const label = content || String(props.label || '')\n    const value = String(props.value || '') || content\n    values.push([value, label === value ? null : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Parent} node\n */\nfunction findOptions(node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<Element>} */\n  let results = []\n  /** @type {Child} */\n  let child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    // @ts-expect-error Looks like a parent.\n    if (Array.isArray(child.children)) {\n      // @ts-expect-error Looks like a parent.\n      results = results.concat(findOptions(child))\n    }\n\n    if (option(child) && !hasProperty(child, 'disabled')) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {own} from '../util/own.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst datalist = convertElement('datalist')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\n// eslint-disable-next-line complexity\nexport function input(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  let value = String(props.value || props.placeholder || '')\n  /** @type {Array<MdastNode>} */\n  const results = []\n  /** @type {Array<string>} */\n  const texts = []\n  /** @type {Array<[string, string|null]>} */\n  let values = []\n  let index = -1\n  /** @type {string} */\n  let list\n\n  if (props.disabled || props.type === 'hidden' || props.type === 'file') {\n    return\n  }\n\n  if (props.type === 'checkbox' || props.type === 'radio') {\n    return h(\n      node,\n      'text',\n      wrapText(h, h[props.checked ? 'checked' : 'unchecked'])\n    )\n  }\n\n  if (props.type === 'image') {\n    return props.alt || value\n      ? h(node, 'image', {\n          url: resolve(h, String(props.src || '') || null),\n          title: wrapText(h, String(props.title || '')) || null,\n          alt: wrapText(h, String(props.alt || value))\n        })\n      : []\n  }\n\n  if (value) {\n    values = [[value, null]]\n  } else if (\n    // `list` is not supported on these types:\n    props.type !== 'password' &&\n    props.type !== 'file' &&\n    props.type !== 'submit' &&\n    props.type !== 'reset' &&\n    props.type !== 'button' &&\n    props.list\n  ) {\n    list = String(props.list).toUpperCase()\n\n    if (own.call(h.nodeById, list) && datalist(h.nodeById[list])) {\n      values = findSelectedOptions(h, h.nodeById[list], props)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (props.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), null]\n  }\n\n  if (props.type === 'url' || props.type === 'email') {\n    while (++index < values.length) {\n      value = resolve(h, values[index][0])\n\n      results.push(\n        h(\n          node,\n          'link',\n          {\n            title: null,\n            url: wrapText(h, props.type === 'email' ? 'mailto:' + value : value)\n          },\n          [{type: 'text', value: wrapText(h, values[index][1] || value)}]\n        )\n      )\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  return h(node, 'text', wrapText(h, texts.join(', ')))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {wrapChildren} from '../util/wrap-children.js'\n\nconst p = convertElement('p')\nconst input = convertElement('input')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function li(h, node) {\n  const head = node.children[0]\n  /** @type {boolean|null} */\n  let checked = null\n  /** @type {ElementChild} */\n  let checkbox\n  /** @type {Element|undefined} */\n  let clone\n\n  // Check if this node starts with a checkbox.\n  if (p(head)) {\n    checkbox = head.children[0]\n\n    if (\n      input(checkbox) &&\n      checkbox.properties &&\n      (checkbox.properties.type === 'checkbox' ||\n        checkbox.properties.type === 'radio')\n    ) {\n      checked = Boolean(checkbox.properties.checked)\n      clone = {\n        ...node,\n        children: [\n          {...head, children: head.children.slice(1)},\n          ...node.children.slice(1)\n        ]\n      }\n    }\n  }\n\n  const content = wrapChildren(h, clone || node)\n\n  return h(node, 'listItem', {spread: content.length > 1, checked}, content)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst ol = convertElement('ol')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function list(h, node) {\n  const ordered = ol(node)\n  const children = wrapListItems(h, node)\n  /** @type {number|null} */\n  let start = null\n\n  if (ordered) {\n    start = hasProperty(node, 'start')\n      ? // @ts-expect-error: `props` exist.\n        Number.parseInt(String(node.properties.start), 10)\n      : 1\n  }\n\n  return h(\n    node,\n    'list',\n    {ordered, start, spread: listItemsSpread(children)},\n    children\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toString} from 'mdast-util-to-string'\nimport {visit, EXIT} from 'unist-util-visit'\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapNeeded} from '../util/wrap.js'\n\nconst source = convertElement('source')\nconst video = convertElement('video')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function media(h, node) {\n  let nodes = all(h, node)\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const properties = node.properties\n  const poster = video(node) && String(properties.poster || '')\n  let src = String(properties.src || '')\n  let index = -1\n  /** @type {boolean} */\n  let linkInFallbackContent = false\n  /** @type {ElementChild} */\n  let child\n\n  visit({type: 'root', children: nodes}, 'link', findLink)\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!src && ++index < node.children.length) {\n    child = node.children[index]\n    if (source(child)) {\n      // @ts-expect-error: `props` are defined.\n      src = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    nodes = [\n      {\n        type: 'image',\n        title: null,\n        url: resolve(h, poster),\n        alt: toString({children: nodes})\n      }\n    ]\n  }\n\n  // Link to the media resource.\n  return {\n    type: 'link',\n    // @ts-expect-error Types are broken.\n    title: node.properties.title || null,\n    url: resolve(h, src),\n    // @ts-expect-error Assume phrasing content.\n    children: nodes\n  }\n\n  function findLink() {\n    linkInFallbackContent = true\n    return EXIT\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function p(h, node) {\n  const nodes = all(h, node)\n\n  if (nodes.length > 0) {\n    return h(node, 'paragraph', nodes)\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function strong(h, node) {\n  return h(node, 'strong', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableCell(h, node) {\n  const wrap = h.wrapText\n\n  h.wrapText = false\n\n  const result = h(node, 'tableCell', all(h, node))\n\n  if (node.properties && (node.properties.rowSpan || node.properties.colSpan)) {\n    const data = result.data || (result.data = {})\n    if (node.properties.rowSpan) data.rowSpan = node.properties.rowSpan\n    if (node.properties.colSpan) data.colSpan = node.properties.colSpan\n  }\n\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastTableContent} MdastTableContent\n * @typedef {import('../types.js').MdastRowContent} MdastRowContent\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n *\n * @typedef Info\n * @property {Array<string|null>} align\n * @property {boolean} headless\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {visit, SKIP} from 'unist-util-visit'\nimport {wrapText} from '../util/wrap-text.js'\nimport {all} from '../all.js'\n\nconst thead = convertElement('thead')\nconst tr = convertElement('tr')\nconst cell = convertElement(['th', 'td'])\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function table(h, node) {\n  if (h.inTable) {\n    return h(node, 'text', wrapText(h, toText(node)))\n  }\n\n  h.inTable = true\n\n  const {headless, align} = inspect(node)\n  const rows = toRows(all(h, node), headless)\n  let columns = 1\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const colSpan = Number.parseInt(String(cell.data.colSpan), 10) || 1\n        const rowSpan = Number.parseInt(String(cell.data.rowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<MdastRowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('colSpan' in cell.data) delete cell.data.colSpan\n        if ('rowSpan' in cell.data) delete cell.data.rowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  h.inTable = false\n\n  return h(node, 'table', {align}, rows)\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Element} node\n * @returns {Info}\n */\nfunction inspect(node) {\n  let headless = true\n  let rowIndex = 0\n  let cellIndex = 0\n  /** @type {Array<string|null>} */\n  const align = [null]\n\n  visit(node, 'element', (child) => {\n    if (child.tagName === 'table' && node !== child) {\n      return SKIP\n    }\n\n    // If there is a `thead`, assume there is a header row.\n    if (cell(child) && child.properties) {\n      if (!align[cellIndex]) {\n        align[cellIndex] = String(child.properties.align || '') || null\n      }\n\n      // If there is a th in the first row, assume there is a header row.\n      if (headless && rowIndex < 2 && child.tagName === 'th') {\n        headless = false\n      }\n\n      cellIndex++\n    } else if (thead(child)) {\n      headless = false\n    } else if (tr(child)) {\n      rowIndex++\n      cellIndex = 0\n    }\n  })\n\n  return {align, headless}\n}\n\n/**\n * Ensure the rows are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @param {boolean} headless\n * @returns {Array<MdastTableContent>}\n */\nfunction toRows(children, headless) {\n  let index = -1\n  /** @type {Array<MdastTableContent>} */\n  const nodes = []\n  /** @type {Array<MdastRowContent>|undefined} */\n  let queue\n\n  // Add an empty header row.\n  if (headless) {\n    nodes.push({type: 'tableRow', children: []})\n  }\n\n  while (++index < children.length) {\n    const node = children[index]\n\n    if (node.type === 'tableRow') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume row content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    nodes[nodes.length - 1].children.push(...queue)\n  }\n\n  index = -1\n\n  while (++index < nodes.length) {\n    nodes[index].children = toCells(nodes[index].children)\n  }\n\n  return nodes\n}\n\n/**\n * Ensure the cells in a row are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @returns {Array<MdastRowContent>}\n */\nfunction toCells(children) {\n  /** @type {Array<MdastRowContent>} */\n  const nodes = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n\n  while (++index < children.length) {\n    node = children[index]\n\n    if (node.type === 'tableCell') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume phrasing content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    node = nodes[nodes.length - 1]\n\n    if (!node) {\n      node = {type: 'tableCell', children: []}\n      nodes.push(node)\n    }\n\n    node.children.push(...queue)\n  }\n\n  return nodes\n}\n","import {all} from '../all.js'\nimport {wrapChildren} from '../util/wrap-children.js'\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\nexport const handlers = {\n  root,\n  text,\n  comment,\n  doctype: ignore,\n\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  address: wrapChildren,\n  article: wrapChildren,\n  aside: wrapChildren,\n  body: wrapChildren,\n  center: wrapChildren,\n  div: wrapChildren,\n  fieldset: wrapChildren,\n  figcaption: wrapChildren,\n  figure: wrapChildren,\n  form: wrapChildren,\n  footer: wrapChildren,\n  header: wrapChildren,\n  hgroup: wrapChildren,\n  html: wrapChildren,\n  legend: wrapChildren,\n  main: wrapChildren,\n  multicol: wrapChildren,\n  nav: wrapChildren,\n  picture: wrapChildren,\n  section: wrapChildren,\n\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\nfunction ignore() {}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Root} Root\n */\n\nimport {all} from '../all.js'\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(h, node) {\n  let children = all(h, node)\n\n  if (h.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  return h(node, 'root', children)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Text} Text\n */\n\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(h, node) {\n  return h(node, 'text', wrapText(h, node.value))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Comment} Comment\n */\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Comment} node\n */\nexport function comment(h, node) {\n  return h(node, 'html', '<!--' + wrapText(h, node.value) + '-->')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function a(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(\n    node,\n    'link',\n    {\n      title: props.title || null,\n      url: resolve(h, String(props.href || '') || null)\n    },\n    all(h, node)\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function base(h, node) {\n  if (!h.baseFound) {\n    h.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || null\n    h.baseFound = true\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {wrapChildren} from '../util/wrap-children.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function blockquote(h, node) {\n  return h(node, 'blockquote', wrapChildren(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function br(h, node) {\n  return h.wrapText ? h(node, 'break') : h(node, 'text', ' ')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function hr(h, node) {\n  return h(node, 'thematicBreak')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function iframe(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  const src = String(props.src || '')\n  const title = String(props.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (src && title) {\n    return {\n      type: 'link',\n      title: null,\n      url: resolve(h, src),\n      children: [{type: 'text', value: wrapText(h, title)}]\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function q(h, node) {\n  const expected = h.quotes[h.qNesting % h.quotes.length]\n\n  h.qNesting++\n  const contents = all(h, node)\n  h.qNesting--\n\n  contents.unshift({type: 'text', value: expected.charAt(0)})\n\n  contents.push({\n    type: 'text',\n    value: expected.length > 1 ? expected.charAt(1) : expected\n  })\n\n  return contents\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function select(h, node) {\n  const values = findSelectedOptions(h, node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n  /** @type {[string, string|null]} */\n  let value\n\n  while (++index < values.length) {\n    value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    return h(node, 'text', wrapText(h, results.join(', ')))\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function textarea(h, node) {\n  return h(node, 'text', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableRow(h, node) {\n  return h(node, 'tableRow', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function wbr(h, node) {\n  return h(node, 'text', '\\u200B')\n}\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Properties} Properties\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').HWithoutProps} HWithoutProps\n * @typedef {import('./types.js').HWithProps} HWithProps\n * @typedef {import('./types.js').MdastNode} MdastNode\n * @typedef {import('./types.js').MdastRoot} MdastRoot\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {convert} from 'unist-util-is'\nimport {visit} from 'unist-util-visit'\nimport {one} from './one.js'\nimport {handlers} from './handlers/index.js'\nimport {own} from './util/own.js'\n\nexport {one} from './one.js'\nexport {all} from './all.js'\n\nconst block = convert(['heading', 'paragraph', 'root'])\n\n/**\n * Transform hast to mdast.\n *\n * @param {Node} tree\n *   Tree (hast).\n * @param {Options} [options]\n *   Configuration (optional).\n */\nexport function toMdast(tree, options = {}) {\n  /** @type {Record<string, Element>} */\n  const byId = {}\n  /** @type {MdastNode|MdastRoot} */\n  let mdast\n\n  /**\n   * @type {H}\n   */\n  const h = Object.assign(\n    /**\n     * @type {HWithProps & HWithoutProps}\n     */\n    (\n      /**\n       * @param {Node} node\n       * @param {string} type\n       * @param {Properties|string|Array<Node>} [props]\n       * @param {string|Array<Node>} [children]\n       */\n      (node, type, props, children) => {\n        /** @type {Properties|undefined} */\n        let properties\n\n        if (typeof props === 'string' || Array.isArray(props)) {\n          children = props\n          properties = {}\n        } else {\n          properties = props\n        }\n\n        /** @type {Node} */\n        // @ts-expect-error Assume valid `type` and `children`/`value`.\n        const result = {type, ...properties}\n\n        if (typeof children === 'string') {\n          // @ts-expect-error: Looks like a literal.\n          result.value = children\n        } else if (children) {\n          // @ts-expect-error: Looks like a parent.\n          result.children = children\n        }\n\n        if (node.position) {\n          result.position = node.position\n        }\n\n        return result\n      }\n    ),\n    {\n      nodeById: byId,\n      baseFound: false,\n      inTable: false,\n      wrapText: true,\n      /** @type {string|null} */\n      frozenBaseUrl: null,\n      qNesting: 0,\n      handlers: options.handlers\n        ? {...handlers, ...options.handlers}\n        : handlers,\n      document: options.document,\n      checked: options.checked || '[x]',\n      unchecked: options.unchecked || '[ ]',\n      quotes: options.quotes || ['\"']\n    }\n  )\n\n  visit(tree, 'element', (node) => {\n    const id =\n      node.properties &&\n      'id' in node.properties &&\n      String(node.properties.id).toUpperCase()\n\n    if (id && !own.call(byId, id)) {\n      byId[id] = node\n    }\n  })\n\n  // @ts-expect-error: does return a transformer, that does accept any node.\n  rehypeMinifyWhitespace({newlines: options.newlines === true})(tree)\n\n  const result = one(h, tree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    mdast = {type: 'root', children: result}\n  } else {\n    mdast = result\n  }\n\n  visit(mdast, 'text', ontext)\n\n  return mdast\n\n  /**\n   * Collapse text nodes, and fix whitespace.\n   * Most of this is taken care of by `rehype-minify-whitespace`, but\n   * we’re generating some whitespace too, and some nodes are in the end\n   * ignored.\n   * So clean up.\n   *\n   * @type {import('unist-util-visit/complex-types').BuildVisitor<MdastRoot, 'text'>}\n   */\n  function ontext(node, index, parent) {\n    /* c8 ignore next 3 */\n    if (index === null || !parent) {\n      return\n    }\n\n    const previous = parent.children[index - 1]\n\n    if (previous && previous.type === node.type) {\n      previous.value += node.value\n      parent.children.splice(index, 1)\n\n      if (previous.position && node.position) {\n        previous.position.end = node.position.end\n      }\n\n      // Iterate over the previous node again, to handle its total value.\n      return index - 1\n    }\n\n    node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n    // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n    // as there the whitespace matters.\n    if (parent && block(parent)) {\n      if (!index) {\n        node.value = node.value.replace(/^[\\t ]+/, '')\n      }\n\n      if (index === parent.children.length - 1) {\n        node.value = node.value.replace(/[\\t ]+$/, '')\n      }\n    }\n\n    if (!node.value) {\n      parent.children.splice(index, 1)\n      return index\n    }\n  }\n}\n\nexport {handlers as defaultHandlers} from './handlers/index.js'\n","/**\n * @typedef {import('hast-util-to-mdast').Options} Options\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new mdast\n * tree (bridge-mode).\n * Without destination, returns the mdast tree: further plugins run on that\n * tree (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `hast-util-to-mdast`.\n */\nconst rehypeRemark =\n  /**\n   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}\n   */\n  (\n    /**\n     * @param {Processor|Options} [destination]\n     * @param {Options} [options]\n     */\n    function (destination, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {Processor|undefined} */\n      let processor\n\n      if (typeof destination === 'function') {\n        processor = destination\n        settings = options || {}\n      } else {\n        settings = destination || {}\n      }\n\n      if (settings.document === undefined || settings.document === null) {\n        settings = Object.assign({}, settings, {document: true})\n      }\n\n      return processor ? bridge(processor, settings) : mutate(settings)\n    }\n  )\n\nexport default rehypeRemark\n\n/**\n * Bridge-mode.\n * Runs the destination with the new mdast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], HastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toMdast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further transformers run on the mdast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>}\n */\nfunction mutate(options = {}) {\n  return (node) => {\n    const result = /** @type {MdastRoot} */ (toMdast(node, options))\n    return result\n  }\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Context} Context\n */\n\n/**\n * @param {Context} base\n * @param {Options} extension\n * @returns {Context}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {string} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../util/indent-lines.js').Map} Map\n */\n\nimport {containerFlow} from '../util/container-flow.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Blockquote} node\n */\nexport function blockquote(node, _, context, safeOptions) {\n  const exit = context.enter('blockquote')\n  const tracker = track(safeOptions)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = indentLines(\n    containerFlow(node, context, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('mdast').Break} Break\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @type {Handle}\n * @param {Break} _\n */\nexport function hardBreak(_, _1, context, safe) {\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      context.unsafe[index].character === '\\n' &&\n      patternInScope(context.stack, context.unsafe[index])\n    ) {\n      return /[ \\t]/.test(safe.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Code} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, context) {\n  return Boolean(\n    !context.options.fences &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n * @typedef {import('../util/indent-lines.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Code} node\n */\nexport function code(node, _, context, safeOptions) {\n  const marker = checkFence(context)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, context)) {\n    const exit = context.enter('codeIndented')\n    const value = indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = track(safeOptions)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = context.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = context.enter('codeFencedLang' + suffix)\n    value += tracker.move(\n      safe(context, node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = context.enter('codeFencedMeta' + suffix)\n    value += tracker.move(' ')\n    value += tracker.move(\n      safe(context, node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['quote'], undefined>}\n */\nexport function checkQuote(context) {\n  const marker = context.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @type {Handle}\n * @param {Emphasis} node\n */\nexport function emphasis(node, _, context, safeOptions) {\n  const marker = checkEmphasis(context)\n  const exit = context.enter('emphasis')\n  const tracker = track(safeOptions)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Emphasis} _\n */\nfunction emphasisPeek(_, _1, context) {\n  return context.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['emphasis'], undefined>}\n */\nexport function checkEmphasis(context) {\n  const marker = context.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, context) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (context.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('../types.js').Handle} Handle\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @type {Handle}\n * @param {HTML} node\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @type {Handle}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nimage.peek = imagePeek\n\n/**\n * @type {Handle}\n * @param {Image} node\n */\nexport function image(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = context.enter('image')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('![')\n  value += tracker.move(\n    safe(context, node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @type {Handle}\n * @param {ImageReference} node\n */\nexport function imageReference(node, _, context, safeOptions) {\n  const type = node.referenceType\n  const exit = context.enter('imageReference')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('![')\n  const alt = safe(context, node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = safe(context, association(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {Context} context\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, context) {\n  const raw = toString(node)\n\n  return Boolean(\n    !context.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nlink.peek = linkPeek\n\n/**\n * @type {Handle}\n * @param {Link} node\n */\nexport function link(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = track(safeOptions)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, context)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = context.stack\n    context.stack = []\n    exit = context.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      containerPhrasing(node, context, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    context.stack = stack\n    return value\n  }\n\n  exit = context.enter('link')\n  subexit = context.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Link} node\n */\nfunction linkPeek(node, _, context) {\n  return formatLinkAsAutolink(node, context) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @type {Handle}\n * @param {LinkReference} node\n */\nexport function linkReference(node, _, context, safeOptions) {\n  const type = node.referenceType\n  const exit = context.enter('linkReference')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('[')\n  const text = containerPhrasing(node, context, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = safe(context, association(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @type {Handle}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bulletOrdered'], undefined>}\n */\nexport function checkBulletOrdered(context) {\n  const marker = context.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['rule'], undefined>}\n */\nexport function checkRule(context) {\n  const marker = context.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @type {Handle}\n * @param {Strong} node\n */\nexport function strong(node, _, context, safeOptions) {\n  const marker = checkStrong(context)\n  const exit = context.enter('strong')\n  const tracker = track(safeOptions)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    containerPhrasing(node, context, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @type {Handle}\n * @param {Strong} _\n */\nfunction strongPeek(_, _1, context) {\n  return context.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['strong'], undefined>}\n */\nexport function checkStrong(context) {\n  const marker = context.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['fence'], undefined>}\n */\nexport function checkFence(context) {\n  const marker = context.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `character` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} character\n *   Single character to look for.\n * @returns {number}\n *   Count of most frequent adjacent `character`s in `value`.\n */\nexport function longestStreak(value, character) {\n  const source = String(value)\n  let index = source.indexOf(character)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof character !== 'string' || character.length !== 1) {\n    throw new Error('Expected character')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + 1\n    index = source.indexOf(character, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {association} from '../util/association.js'\nimport {checkQuote} from '../util/check-quote.js'\nimport {safe} from '../util/safe.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Definition} node\n */\nexport function definition(node, _, context, safeOptions) {\n  const quote = checkQuote(context)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = context.enter('definition')\n  let subexit = context.enter('label')\n  const tracker = track(safeOptions)\n  let value = tracker.move('[')\n  value += tracker.move(\n    safe(context, association(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += tracker.move(\n      safe(context, node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      safe(context, node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {Heading} node\n */\nexport function heading(node, _, context, safeOptions) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = track(safeOptions)\n\n  if (formatHeadingAsSetext(node, context)) {\n    const exit = context.enter('headingSetext')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = context.enter('headingAtx')\n  const subexit = context.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = containerPhrasing(node, context, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (context.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerFlow} from '../util/container-flow.js'\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @type {Handle}\n * @param {List} node\n */\nexport function list(node, parent, context, safeOptions) {\n  const exit = context.enter('list')\n  const bulletCurrent = context.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(context) : checkBullet(context)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(context)\n    : checkBulletOther(context)\n  const bulletLastUsed = context.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? context.options.bulletOrderedOther\n      : context.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      context.stack[context.stack.length - 1] === 'list' &&\n      context.stack[context.stack.length - 2] === 'listItem' &&\n      context.stack[context.stack.length - 3] === 'list' &&\n      context.stack[context.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      context.indexStack[context.indexStack.length - 1] === 0 &&\n      context.indexStack[context.indexStack.length - 2] === 0 &&\n      context.indexStack[context.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(context) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  context.bulletCurrent = bullet\n  const value = containerFlow(node, context, safeOptions)\n  context.bulletLastUsed = bullet\n  context.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bulletOrdered'], undefined>}\n */\nexport function checkBulletOrderedOther(context) {\n  const bulletOrdered = checkBulletOrdered(context)\n  const bulletOrderedOther = context.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bullet'], undefined>}\n */\nexport function checkBulletOther(context) {\n  const bullet = checkBullet(context)\n  const bulletOther = context.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerPhrasing} from '../util/container-phrasing.js'\n\n/**\n * @type {Handle}\n * @param {Paragraph} node\n */\nexport function paragraph(node, _, context, safeOptions) {\n  const exit = context.enter('paragraph')\n  const subexit = context.enter('phrasing')\n  const value = containerPhrasing(node, context, safeOptions)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {containerFlow} from '../util/container-flow.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(node, _, context, safeOptions) {\n  return containerFlow(node, context, safeOptions)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {safe} from '../util/safe.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(node, _, context, safeOptions) {\n  return safe(context, node.value, safeOptions)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @type {Handle}\n * @param {ThematicBreak} _\n */\nexport function thematicBreak(_, _1, context) {\n  const value = (\n    checkRule(context) + (context.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(context))\n\n  return context.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['ruleRepetition'], undefined>}\n */\nexport function checkRuleRepetition(context) {\n  const repetition = context.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, context) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, context) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, context)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? context.options.bulletOrderedOther\n      : context.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, context)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Context} Context\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').Unsafe} Unsafe\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\n\n/**\n * @param {Node} tree\n * @param {Options} [options]\n * @returns {string}\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {Context} */\n  // @ts-expect-error: we’ll add `handle` later.\n  const context = {\n    enter,\n    stack: [],\n    unsafe: [],\n    join: [],\n    handlers: {},\n    options: {},\n    indexStack: []\n  }\n\n  configure(context, {unsafe, join, handlers: handle})\n  configure(context, options)\n\n  if (context.options.tightDefinitions) {\n    configure(context, {join: [joinDefinition]})\n  }\n\n  /** @type {Handle} */\n  context.handle = zwitch('type', {\n    invalid,\n    // @ts-expect-error: hush.\n    unknown,\n    // @ts-expect-error: hush.\n    handlers: context.handlers\n  })\n\n  let result = context.handle(tree, null, context, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Context['enter']} */\n  function enter(name) {\n    context.stack.push(name)\n    return exit\n\n    function exit() {\n      context.stack.pop()\n    }\n  }\n}\n\n/**\n * @type {Handle}\n * @param {unknown} value\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n","import remarkStringify from './lib/index.js'\n\nexport default remarkStringify\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/** @type {import('unified').Plugin<[Options]|void[], Node, string>} */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],"names":["errors","abandonedHeadElementChild","reason","description","url","abruptClosingOfEmptyComment","abruptDoctypePublicIdentifier","abruptDoctypeSystemIdentifier","absenceOfDigitsInNumericCharacterReference","cdataInHtmlContent","characterReferenceOutsideUnicodeRange","closingOfElementWithOpenChildElements","controlCharacterInInputStream","controlCharacterReference","disallowedContentInNoscriptInHead","duplicateAttribute","endTagWithAttributes","endTagWithTrailingSolidus","endTagWithoutMatchingOpenElement","eofBeforeTagName","eofInCdata","eofInComment","eofInDoctype","eofInElementThatCanContainOnlyText","eofInScriptHtmlCommentLikeText","eofInTag","incorrectlyClosedComment","incorrectlyOpenedComment","invalidCharacterSequenceAfterDoctypeName","invalidFirstCharacterOfTagName","misplacedDoctype","misplacedStartTagForHeadElement","missingAttributeValue","missingDoctype","missingDoctypeName","missingDoctypePublicIdentifier","missingDoctypeSystemIdentifier","missingEndTagName","missingQuoteBeforeDoctypePublicIdentifier","missingQuoteBeforeDoctypeSystemIdentifier","missingSemicolonAfterCharacterReference","missingWhitespaceAfterDoctypePublicKeyword","missingWhitespaceAfterDoctypeSystemKeyword","missingWhitespaceBeforeDoctypeName","missingWhitespaceBetweenAttributes","missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers","nestedComment","nestedNoscriptInHead","nonConformingDoctype","nonVoidHtmlElementStartTagWithTrailingSolidus","noncharacterCharacterReference","noncharacterInInputStream","nullCharacterReference","openElementsLeftAfterEof","surrogateCharacterReference","surrogateInInputStream","unexpectedCharacterAfterDoctypeSystemIdentifier","unexpectedCharacterInAttributeName","unexpectedCharacterInUnquotedAttributeValue","unexpectedEqualsSignBeforeAttributeName","unexpectedNullCharacter","unexpectedQuestionMarkInsteadOfTagName","unexpectedSolidusInTag","unknownNamedCharacterReference","base","fatalities","rehypeParse","options","processorSettings","this","data","settings","Object","assign","Parser","doc","file","fn","fragment","onParseError","emitParseErrors","error","code","name","value","replace","$0","charAt","toUpperCase","setting","config","undefined","level","start","line","startLine","column","startCol","offset","startOffset","end","endLine","endCol","endOffset","info","message","format","source","ruleId","fatal","note","_","$1","Number","parseInt","char","charCodeAt","toString","parse5","Parser5","sourceCodeLocationInfo","scriptingEnabled","fromParse5","space","verbose","all","h","parent","nodes","children","values","index","length","child","type","tagName","result","one","Array","isArray","push","own","hasOwnProperty","wrapText","node","properties","dataMdast","call","handlers","unknown","phrasing","convert","wrap","runs","head","wrapNeeded","onphrasing","onnonphrasing","queue","nonphrasing","identity","flattened","concat","split","flatten","rest","extend","hName","hastPhrasing","mdastPhrasing","n","wrapChildren","resolve","frozenBaseUrl","String","URL","findAfter","test","is","Error","POSITIVE_INFINITY","indexOf","searchLineFeeds","searchTabOrSpaces","br","convertElement","p","cell","row","notRendered","Boolean","hidden","open","blockOrCaption","toText","results","count","block","whitespace","inferWhitespace","breakBefore","breakAfter","collectText","innerTextCollection","repeat","join","prefix","suffix","items","unshift","collectElement","collectPreText","match","lines","lastIndex","exec","trimAndCollapseSpacesAndTabs","slice","props","noWrap","pre","isCode","classList","lang","className","meta","del","listItemsSpread","spread","wrapListItems","checked","div","dt","dd","handle","ordered","em","heading","depth","img","src","title","alt","inlineCode","option","findSelectedOptions","findOptions","size","Math","min","multiple","selectedOptions","hasProperty","content","label","datalist","input","li","checkbox","clone","ol","list","video","media","poster","linkInFallbackContent","visit","EXIT","strong","tableCell","rowSpan","colSpan","thead","tr","toCells","root","document","text","comment","doctype","ignore","applet","area","basefont","bgsound","caption","col","colgroup","command","dialog","element","embed","frame","frameset","isindex","keygen","link","math","menu","menuitem","nextid","noembed","noframes","optgroup","param","script","shadow","spacer","style","svg","template","track","abbr","acronym","bdi","bdo","big","blink","button","canvas","cite","details","dfn","font","ins","map","marquee","meter","nobr","noscript","object","output","progress","rb","rbc","rp","rt","rtc","ruby","slot","small","span","sup","sub","tbody","tfoot","time","address","article","aside","body","center","fieldset","figcaption","figure","form","footer","header","hgroup","html","legend","main","multicol","nav","picture","section","a","href","audio","b","baseFound","blockquote","dir","dl","clean","groups","group","titles","definitions","h1","h2","h3","h4","h5","h6","hr","i","iframe","image","placeholder","texts","disabled","nodeById","kbd","listing","mark","plaintext","q","expected","quotes","qNesting","contents","s","samp","select","strike","summary","table","inTable","headless","rowIndex","cellIndex","align","SKIP","inspect","rows","toRows","columns","cells","otherRowIndex","colIndex","newCells","splice","keys","alignIndex","td","textarea","th","tt","u","ul","var","wbr","xmp","toMdast","tree","mdast","byId","position","unchecked","id","rehypeMinifyWhitespace","newlines","ontext","previous","destination","processor","next","run","bridge","mutate","configure","extension","key","extensions","blank","hardBreak","_1","context","safe","unsafe","character","patternInScope","stack","before","formatCodeAsIndented","fences","checkQuote","marker","quote","emphasis","safeOptions","checkEmphasis","exit","enter","tracker","move","containerPhrasing","after","current","peek","formatHeadingAsSetext","literalWithBreak","setext","subexit","imageReference","referenceType","reference","association","formatLinkAsAutolink","raw","resourceLink","linkReference","checkBulletOrdered","bulletOrdered","checkRule","rule","checkStrong","shift","indentLines","containerFlow","break","fence","checkFence","sequence","max","longestStreak","encode","definition","rank","lastIndexOf","closeAtx","bulletCurrent","bullet","checkBullet","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","bulletLastUsed","useDifferentMarker","firstListItem","indexStack","item","listItem","paragraph","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","left","right","fullPhrasingSpans","inConstruct","notInConstruct","atBreak","invalid","joinDefinition","Compiler","tightDefinitions","zwitch","now","lineShift","pop","toMarkdown"],"sourceRoot":""}