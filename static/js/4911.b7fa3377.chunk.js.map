{"version":3,"file":"static/js/4911.b7fa3377.chunk.js","mappings":"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","sources":["../../packages/json-ini/esm/sample.js","../../packages/json-ini/esm/index.js","../../packages/json-ini/node_modules/ini/lib/ini.js","../../node_modules/@lezer/json/dist/index.js","../../node_modules/@codemirror/lang-json/dist/index.js","../../node_modules/@codemirror/legacy-modes/mode/yaml.js"],"sourcesContent":["export var json = \"{\\n  \\\"app_mode\\\": \\\"development\\\",\\n  \\\"paths\\\": {\\n    \\\"data\\\": \\\"/home/git/grafana\\\"\\n  },\\n  \\\"server\\\": {\\n    \\\"protocol\\\": \\\"http\\\",\\n    \\\"http_port\\\": \\\"9999\\\",\\n    \\\"enforce_domain\\\": true\\n  }\\n}\";\nexport var val = \"# possible values : production, development\\napp_mode = development\\n\\n[paths]\\n# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used)\\ndata = /home/git/grafana\\n\\n[server]\\n# Protocol (http or https)\\nprotocol = http\\n\\n# The http port  to use\\nhttp_port = 9999\\n\\n# Redirect to correct domain if host header does not match domain\\n# Prevents DNS rebinding attacks\\nenforce_domain = true\";","import { LayoutEditorConverter } from '@wcj/tools-react-components';\nimport ini from 'ini';\nimport { StreamLanguage } from '@codemirror/language';\nimport { yaml } from '@codemirror/legacy-modes/mode/yaml';\nimport { json } from '@codemirror/lang-json';\nimport * as sample from './sample';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default function JSON2Ini() {\n  return /*#__PURE__*/_jsx(LayoutEditorConverter, {\n    sample: sample,\n    leftProps: {\n      title: 'JSON',\n      extensions: [json()],\n      onLeftInput: val => {\n        var iniStr = ini.stringify(JSON.parse(val));\n        return iniStr;\n      }\n    },\n    rightProps: {\n      title: 'INI',\n      extensions: [StreamLanguage.define(yaml)],\n      onRightInput: val => {\n        var jsonStr = JSON.stringify(ini.parse(val), null, 2);\n        return jsonStr;\n      }\n    }\n  });\n}","const { hasOwnProperty } = Object.prototype\n\nconst encode = (obj, opt = {}) => {\n  if (typeof opt === 'string') {\n    opt = { section: opt }\n  }\n  opt.align = opt.align === true\n  opt.newline = opt.newline === true\n  opt.sort = opt.sort === true\n  opt.whitespace = opt.whitespace === true || opt.align === true\n  // The `typeof` check is required because accessing the `process` directly fails on browsers.\n  /* istanbul ignore next */\n  opt.platform = opt.platform || (typeof process !== 'undefined' && process.platform)\n  opt.bracketedArray = opt.bracketedArray !== false\n\n  /* istanbul ignore next */\n  const eol = opt.platform === 'win32' ? '\\r\\n' : '\\n'\n  const separator = opt.whitespace ? ' = ' : '='\n  const children = []\n\n  const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj)\n\n  let padToChars = 0\n  // If aligning on the separator, then padToChars is determined as follows:\n  // 1. Get the keys\n  // 2. Exclude keys pointing to objects unless the value is null or an array\n  // 3. Add `[]` to array keys\n  // 4. Ensure non empty set of keys\n  // 5. Reduce the set to the longest `safe` key\n  // 6. Get the `safe` length\n  if (opt.align) {\n    padToChars = safe(\n      (\n        keys\n          .filter(k => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== 'object')\n          .map(k => Array.isArray(obj[k]) ? `${k}[]` : k)\n      )\n        .concat([''])\n        .reduce((a, b) => safe(a).length >= safe(b).length ? a : b)\n    ).length\n  }\n\n  let out = ''\n  const arraySuffix = opt.bracketedArray ? '[]' : ''\n\n  for (const k of keys) {\n    const val = obj[k]\n    if (val && Array.isArray(val)) {\n      for (const item of val) {\n        out += safe(`${k}${arraySuffix}`).padEnd(padToChars, ' ') + separator + safe(item) + eol\n      }\n    } else if (val && typeof val === 'object') {\n      children.push(k)\n    } else {\n      out += safe(k).padEnd(padToChars, ' ') + separator + safe(val) + eol\n    }\n  }\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + (opt.newline ? eol + eol : eol) + out\n  }\n\n  for (const k of children) {\n    const nk = splitSections(k, '.').join('\\\\.')\n    const section = (opt.section ? opt.section + '.' : '') + nk\n    const child = encode(obj[k], {\n      ...opt,\n      section,\n    })\n    if (out.length && child.length) {\n      out += eol\n    }\n\n    out += child\n  }\n\n  return out\n}\n\nfunction splitSections (str, separator) {\n  var lastMatchIndex = 0\n  var lastSeparatorIndex = 0\n  var nextIndex = 0\n  var sections = []\n\n  do {\n    nextIndex = str.indexOf(separator, lastMatchIndex)\n\n    if (nextIndex !== -1) {\n      lastMatchIndex = nextIndex + separator.length\n\n      if (nextIndex > 0 && str[nextIndex - 1] === '\\\\') {\n        continue\n      }\n\n      sections.push(str.slice(lastSeparatorIndex, nextIndex))\n      lastSeparatorIndex = nextIndex + separator.length\n    }\n  } while (nextIndex !== -1)\n\n  sections.push(str.slice(lastSeparatorIndex))\n\n  return sections\n}\n\nconst decode = (str, opt = {}) => {\n  opt.bracketedArray = opt.bracketedArray !== false\n  const out = Object.create(null)\n  let p = out\n  let section = null\n  //          section          |key      = value\n  const re = /^\\[([^\\]]*)\\]\\s*$|^([^=]+)(=(.*))?$/i\n  const lines = str.split(/[\\r\\n]+/g)\n  const duplicates = {}\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/) || line.match(/^\\s*$/)) {\n      continue\n    }\n    const match = line.match(re)\n    if (!match) {\n      continue\n    }\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null)\n        continue\n      }\n      p = out[section] = out[section] || Object.create(null)\n      continue\n    }\n    const keyRaw = unsafe(match[2])\n    let isArray\n    if (opt.bracketedArray) {\n      isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]'\n    } else {\n      duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1\n      isArray = duplicates[keyRaw] > 1\n    }\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw\n    if (key === '__proto__') {\n      continue\n    }\n    const valueRaw = match[3] ? unsafe(match[4]) : true\n    const value = valueRaw === 'true' ||\n      valueRaw === 'false' ||\n      valueRaw === 'null' ? JSON.parse(valueRaw)\n      : valueRaw\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) {\n        p[key] = []\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]]\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    } else {\n      p[key] = value\n    }\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = []\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k])) {\n      continue\n    }\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = splitSections(k, '.')\n    p = out\n    const l = parts.pop()\n    const nl = l.replace(/\\\\\\./g, '.')\n    for (const part of parts) {\n      if (part === '__proto__') {\n        continue\n      }\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {\n        p[part] = Object.create(null)\n      }\n      p = p[part]\n    }\n    if (p === out && nl === l) {\n      continue\n    }\n\n    p[nl] = out[k]\n    remove.push(k)\n  }\n  for (const del of remove) {\n    delete out[del]\n  }\n\n  return out\n}\n\nconst isQuoted = val => {\n  return (val.startsWith('\"') && val.endsWith('\"')) ||\n    (val.startsWith(\"'\") && val.endsWith(\"'\"))\n}\n\nconst safe = val => {\n  if (\n    typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 && isQuoted(val)) ||\n    val !== val.trim()\n  ) {\n    return JSON.stringify(val)\n  }\n  return val.split(';').join('\\\\;').split('#').join('\\\\#')\n}\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.slice(1, -1)\n    }\n    try {\n      val = JSON.parse(val)\n    } catch {\n      // ignore errors\n    }\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false\n    let unesc = ''\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c\n        } else {\n          unesc += '\\\\' + c\n        }\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1) {\n        break\n      } else if (c === '\\\\') {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc) {\n      unesc += '\\\\'\n    }\n\n    return unesc.trim()\n  }\n  return val\n}\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe,\n}\n","import { LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\nconst jsonHighlighting = styleTags({\n  String: tags.string,\n  Number: tags.number,\n  \"True False\": tags.bool,\n  PropertyName: tags.propertyName,\n  Null: tags.null,\n  \",\": tags.separator,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j\",\n  stateData: \"#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O\",\n  goto: \"!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \"âš  JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 25,\n  nodeProps: [\n    [\"isolate\", -2,6,11,\"\"],\n    [\"openedBy\", 7,\"{\",12,\"[\"],\n    [\"closedBy\", 8,\"}\",13,\"]\"]\n  ],\n  propSources: [jsonHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~\",\n  tokenizers: [0],\n  topRules: {\"JsonText\":[0,1]},\n  tokenPrec: 0\n});\n\nexport { parser };\n","import { parser } from '@lezer/json';\nimport { LRLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\n/**\nCalls\n[`JSON.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\non the document and, if that throws an error, reports it as a\nsingle diagnostic.\n*/\nconst jsonParseLinter = () => (view) => {\n    try {\n        JSON.parse(view.state.doc.toString());\n    }\n    catch (e) {\n        if (!(e instanceof SyntaxError))\n            throw e;\n        const pos = getErrorPosition(e, view.state.doc);\n        return [{\n                from: pos,\n                message: e.message,\n                severity: 'error',\n                to: pos\n            }];\n    }\n    return [];\n};\nfunction getErrorPosition(error, doc) {\n    let m;\n    if (m = error.message.match(/at position (\\d+)/))\n        return Math.min(+m[1], doc.length);\n    if (m = error.message.match(/at line (\\d+) column (\\d+)/))\n        return Math.min(doc.line(+m[1]).from + (+m[2]) - 1, doc.length);\n    return 0;\n}\n\n/**\nA language provider that provides JSON parsing.\n*/\nconst jsonLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"json\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Object: /*@__PURE__*/continuedIndent({ except: /^\\s*\\}/ }),\n                Array: /*@__PURE__*/continuedIndent({ except: /^\\s*\\]/ })\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Object Array\": foldInside\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"[\", \"{\", '\"'] },\n        indentOnInput: /^\\s*[\\}\\]]$/\n    }\n});\n/**\nJSON language support.\n*/\nfunction json() {\n    return new LanguageSupport(jsonLanguage);\n}\n\nexport { json, jsonLanguage, jsonParseLinter };\n","var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\nvar keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\nexport const yaml = {\n  name: \"yaml\",\n  token: function(stream, state) {\n    var ch = stream.peek();\n    var esc = state.escaped;\n    state.escaped = false;\n    /* comments */\n    if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n      return \"string\";\n\n    if (state.literal && stream.indentation() > state.keyCol) {\n      stream.skipToEnd(); return \"string\";\n    } else if (state.literal) { state.literal = false; }\n    if (stream.sol()) {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      /* document start */\n      if(stream.match('---')) { return \"def\"; }\n      /* document end */\n      if (stream.match('...')) { return \"def\"; }\n      /* array list item */\n      if (stream.match(/^\\s*-\\s+/)) { return 'meta'; }\n    }\n    /* inline pairs/lists */\n    if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n      if (ch == '{')\n        state.inlinePairs++;\n      else if (ch == '}')\n        state.inlinePairs--;\n      else if (ch == '[')\n        state.inlineList++;\n      else\n        state.inlineList--;\n      return 'meta';\n    }\n\n    /* list separator */\n    if (state.inlineList > 0 && !esc && ch == ',') {\n      stream.next();\n      return 'meta';\n    }\n    /* pairs separator */\n    if (state.inlinePairs > 0 && !esc && ch == ',') {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      stream.next();\n      return 'meta';\n    }\n\n    /* start of value of a pair */\n    if (state.pairStart) {\n      /* block literals */\n      if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n      /* references */\n      if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable'; }\n      /* numbers */\n      if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n      if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n      /* keywords */\n      if (stream.match(keywordRegex)) { return 'keyword'; }\n    }\n\n    /* pairs (associative arrays) -> key */\n    if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n      state.pair = true;\n      state.keyCol = stream.indentation();\n      return \"atom\";\n    }\n    if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n    /* nothing found, continue */\n    state.pairStart = false;\n    state.escaped = (ch == '\\\\');\n    stream.next();\n    return null;\n  },\n  startState: function() {\n    return {\n      pair: false,\n      pairStart: false,\n      keyCol: 0,\n      inlinePairs: 0,\n      inlineList: 0,\n      literal: false,\n      escaped: false\n    };\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["json","val","JSON2Ini","_jsx","LayoutEditorConverter","sample","leftProps","title","extensions","onLeftInput","ini","JSON","parse","rightProps","StreamLanguage","define","yaml","onRightInput","stringify","hasOwnProperty","Object","prototype","encode","obj","opt","arguments","length","undefined","section","align","newline","sort","whitespace","platform","process","bracketedArray","eol","separator","children","keys","padToChars","safe","filter","k","Array","isArray","map","concat","reduce","a","b","out","arraySuffix","item","padEnd","push","nk","splitSections","join","child","str","lastMatchIndex","lastSeparatorIndex","nextIndex","sections","indexOf","slice","decode","create","p","re","lines","split","duplicates","line","match","unsafe","keyRaw","key","valueRaw","value","call","remove","parts","l","pop","nl","replace","part","del","isQuoted","startsWith","endsWith","trim","doUnesc","esc","unesc","i","c","charAt","module","exports","jsonHighlighting","styleTags","String","tags","string","Number","number","bool","PropertyName","propertyName","Null","null","squareBracket","brace","parser","LRParser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","propSources","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","tokenPrec","jsonParseLinter","view","state","doc","toString","e","SyntaxError","pos","error","m","message","Math","min","from","getErrorPosition","severity","to","jsonLanguage","LRLanguage","name","configure","props","indentNodeProp","add","continuedIndent","except","foldNodeProp","foldInside","languageData","closeBrackets","brackets","indentOnInput","LanguageSupport","keywordRegex","RegExp","token","stream","ch","peek","escaped","test","skipToEnd","literal","indentation","keyCol","sol","pair","pairStart","inlinePairs","inlineList","next","startState","commentTokens"],"sourceRoot":""}